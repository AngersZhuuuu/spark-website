<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_45) on Wed Jul 08 16:13:39 PDT 2015 -->
<TITLE>
SparkContext (Spark 1.4.1 JavaDoc)
</TITLE>

<META NAME="date" CONTENT="2015-07-08">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SparkContext (Spark 1.4.1 JavaDoc)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/apache/spark/SparkContext.DoubleAccumulatorParam$.html" title="class in org.apache.spark"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/apache/spark/SparkContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SparkContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.apache.spark</FONT>
<BR>
Class SparkContext</H2>
<PRE>
Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.apache.spark.SparkContext</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../org/apache/spark/Logging.html" title="interface in org.apache.spark">Logging</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>SparkContext</B><DT>extends Object<DT>implements <A HREF="../../../org/apache/spark/Logging.html" title="interface in org.apache.spark">Logging</A></DL>
</PRE>

<P>
Main entry point for Spark functionality. A SparkContext represents the connection to a Spark
 cluster, and can be used to create RDDs, accumulators and broadcast variables on that cluster.
 <p>
 Only one SparkContext may be active per JVM.  You must <code>stop()</code> the active SparkContext before
 creating a new one.  This limitation may eventually be removed; see SPARK-2243 for more details.
 <p>
 param:  config a Spark Config object describing the application configuration. Any settings in
   this config overrides the default configs as well as system properties.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.DoubleAccumulatorParam$.html" title="class in org.apache.spark">SparkContext.DoubleAccumulatorParam$</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.FloatAccumulatorParam$.html" title="class in org.apache.spark">SparkContext.FloatAccumulatorParam$</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.IntAccumulatorParam$.html" title="class in org.apache.spark">SparkContext.IntAccumulatorParam$</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.LongAccumulatorParam$.html" title="class in org.apache.spark">SparkContext.LongAccumulatorParam$</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#SparkContext()">SparkContext</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a SparkContext that loads settings from system properties (for instance, when
 launching with ./bin/spark-submit).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#SparkContext(org.apache.spark.SparkConf)">SparkContext</A></B>(<A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;config)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#SparkContext(org.apache.spark.SparkConf, scala.collection.Map)">SparkContext</A></B>(<A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;config,
             scala.collection.Map&lt;String,scala.collection.Set&lt;<A HREF="../../../org/apache/spark/scheduler/SplitInfo.html" title="class in org.apache.spark.scheduler">SplitInfo</A>&gt;&gt;&nbsp;preferredNodeLocationData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Alternative constructor for setting preferred locations where Spark will create executors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#SparkContext(java.lang.String, java.lang.String, org.apache.spark.SparkConf)">SparkContext</A></B>(String&nbsp;master,
             String&nbsp;appName,
             <A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;conf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alternative constructor that allows setting common Spark properties directly</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#SparkContext(java.lang.String, java.lang.String, java.lang.String, scala.collection.Seq, scala.collection.Map, scala.collection.Map)">SparkContext</A></B>(String&nbsp;master,
             String&nbsp;appName,
             String&nbsp;sparkHome,
             scala.collection.Seq&lt;String&gt;&nbsp;jars,
             scala.collection.Map&lt;String,String&gt;&nbsp;environment,
             scala.collection.Map&lt;String,scala.collection.Set&lt;<A HREF="../../../org/apache/spark/scheduler/SplitInfo.html" title="class in org.apache.spark.scheduler">SplitInfo</A>&gt;&gt;&nbsp;preferredNodeLocationData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alternative constructor that allows setting common Spark properties directly</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R,T&gt; <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark">Accumulable</A>&lt;R,T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#accumulable(R, org.apache.spark.AccumulableParam)">accumulable</A></B>(R&nbsp;initialValue,
            <A HREF="../../../org/apache/spark/AccumulableParam.html" title="interface in org.apache.spark">AccumulableParam</A>&lt;R,T&gt;&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark"><CODE>Accumulable</CODE></A> shared variable, to which tasks can add values
 with <code>+=</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R,T&gt; <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark">Accumulable</A>&lt;R,T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#accumulable(R, java.lang.String, org.apache.spark.AccumulableParam)">accumulable</A></B>(R&nbsp;initialValue,
            String&nbsp;name,
            <A HREF="../../../org/apache/spark/AccumulableParam.html" title="interface in org.apache.spark">AccumulableParam</A>&lt;R,T&gt;&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark"><CODE>Accumulable</CODE></A> shared variable, with a name for display in the
 Spark UI.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R,T&gt; <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark">Accumulable</A>&lt;R,T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#accumulableCollection(R, scala.Function1, scala.reflect.ClassTag)">accumulableCollection</A></B>(R&nbsp;initialValue,
                      scala.Function1&lt;R,scala.collection.generic.Growable&lt;T&gt;&gt;&nbsp;evidence$9,
                      scala.reflect.ClassTag&lt;R&gt;&nbsp;evidence$10)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an accumulator from a "mutable collection" type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/Accumulator.html" title="class in org.apache.spark">Accumulator</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#accumulator(T, org.apache.spark.AccumulatorParam)">accumulator</A></B>(T&nbsp;initialValue,
            <A HREF="../../../org/apache/spark/AccumulatorParam.html" title="interface in org.apache.spark">AccumulatorParam</A>&lt;T&gt;&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an <A HREF="../../../org/apache/spark/Accumulator.html" title="class in org.apache.spark"><CODE>Accumulator</CODE></A> variable of a given type, which tasks can "add"
 values to using the <code>+=</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/Accumulator.html" title="class in org.apache.spark">Accumulator</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#accumulator(T, java.lang.String, org.apache.spark.AccumulatorParam)">accumulator</A></B>(T&nbsp;initialValue,
            String&nbsp;name,
            <A HREF="../../../org/apache/spark/AccumulatorParam.html" title="interface in org.apache.spark">AccumulatorParam</A>&lt;T&gt;&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an <A HREF="../../../org/apache/spark/Accumulator.html" title="class in org.apache.spark"><CODE>Accumulator</CODE></A> variable of a given type, with a name for display
 in the Spark UI.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.collection.mutable.HashMap&lt;String,Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#addedFiles()">addedFiles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.collection.mutable.HashMap&lt;String,Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#addedJars()">addedJars</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#addFile(java.lang.String)">addFile</A></B>(String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a file to be downloaded with this Spark job on every node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#addFile(java.lang.String, boolean)">addFile</A></B>(String&nbsp;path,
        boolean&nbsp;recursive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a file to be downloaded with this Spark job on every node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#addJar(java.lang.String)">addJar</A></B>(String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a JAR dependency for all tasks to be executed on this SparkContext in the future.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#addSparkListener(org.apache.spark.scheduler.SparkListener)">addSparkListener</A></B>(<A HREF="../../../org/apache/spark/scheduler/SparkListener.html" title="interface in org.apache.spark.scheduler">SparkListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Register a listener to receive up-calls from events that happen during execution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.Option&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#applicationAttemptId()">applicationAttemptId</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#applicationId()">applicationId</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#appName()">appName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;String,<A HREF="../../../org/apache/spark/input/PortableDataStream.html" title="class in org.apache.spark.input">PortableDataStream</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#binaryFiles(java.lang.String, int)">binaryFiles</A></B>(String&nbsp;path,
            int&nbsp;minPartitions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Experimental ::</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#binaryRecords(java.lang.String, int, org.apache.hadoop.conf.Configuration)">binaryRecords</A></B>(String&nbsp;path,
              int&nbsp;recordLength,
              org.apache.hadoop.conf.Configuration&nbsp;conf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Experimental ::</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.spark.WritableConverter&lt;Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#booleanWritableConverter()">booleanWritableConverter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.hadoop.io.BooleanWritable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#boolToBoolWritable(boolean)">boolToBoolWritable</A></B>(boolean&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/broadcast/Broadcast.html" title="class in org.apache.spark.broadcast">Broadcast</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#broadcast(T, scala.reflect.ClassTag)">broadcast</A></B>(T&nbsp;value,
          scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$11)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Broadcast a read-only variable to the cluster, returning a
 <A HREF="../../../org/apache/spark/broadcast/Broadcast.html" title="class in org.apache.spark.broadcast"><CODE>Broadcast</CODE></A> object for reading it in distributed functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.hadoop.io.BytesWritable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#bytesToBytesWritable(byte[])">bytesToBytesWritable</A></B>(byte[]&nbsp;aob)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.spark.WritableConverter&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#bytesWritableConverter()">bytesWritableConverter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#cancelAllJobs()">cancelAllJobs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cancel all jobs that have been scheduled or are running.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#cancelJobGroup(java.lang.String)">cancelJobGroup</A></B>(String&nbsp;groupId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cancel active jobs for the specified group.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.Option&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#checkpointDir()">checkpointDir</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#clearCallSite()">clearCallSite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear the thread-local property for overriding the call sites
 of actions and RDDs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#clearFiles()">clearFiles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear the job's list of files added by <code>addFile</code> so that they do not get downloaded to
 any new nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#clearJars()">clearJars</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear the job's list of JARs added by <code>addJar</code> so that they do not get downloaded to
 any new nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#clearJobGroup()">clearJobGroup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear the current thread's job group ID and its description.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#defaultMinPartitions()">defaultMinPartitions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default min number of partitions for Hadoop RDDs when not given by user
 Notice that we use math.min so the "defaultMinPartitions" cannot be higher than 2.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#defaultMinSplits()">defaultMinSplits</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default min number of partitions for Hadoop RDDs when not given by user</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#defaultParallelism()">defaultParallelism</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default level of parallelism to use when not given by user (e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/apache/spark/rdd/DoubleRDDFunctions.html" title="class in org.apache.spark.rdd">DoubleRDDFunctions</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#doubleRDDToDoubleRDDFunctions(org.apache.spark.rdd.RDD)">doubleRDDToDoubleRDDFunctions</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;Object&gt;&nbsp;rdd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.hadoop.io.DoubleWritable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#doubleToDoubleWritable(double)">doubleToDoubleWritable</A></B>(double&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.spark.WritableConverter&lt;Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#doubleWritableConverter()">doubleWritableConverter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#DRIVER_IDENTIFIER()">DRIVER_IDENTIFIER</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executor id for the driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <any></CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#emptyRDD(scala.reflect.ClassTag)">emptyRDD</A></B>(scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$8)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an RDD that has no partitions or elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.collection.mutable.HashMap&lt;String,String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#executorEnvs()">executorEnvs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#externalBlockStoreFolderName()">externalBlockStoreFolderName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.collection.Seq&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#files()">files</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.hadoop.io.FloatWritable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#floatToFloatWritable(float)">floatToFloatWritable</A></B>(float&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.spark.WritableConverter&lt;Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#floatWritableConverter()">floatWritableConverter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.collection.Seq&lt;org.apache.spark.scheduler.Schedulable&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getAllPools()">getAllPools</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Return pools for fair scheduler</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.Option&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getCheckpointDir()">getCheckpointDir</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getConf()">getConf</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a copy of this SparkContext's configuration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.collection.Map&lt;String,scala.Tuple2&lt;Object,Object&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getExecutorMemoryStatus()">getExecutorMemoryStatus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a map from the slave to the max memory available for caching and the remaining
 memory available for caching.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/apache/spark/storage/StorageStatus.html" title="class in org.apache.spark.storage">StorageStatus</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getExecutorStorageStatus()">getExecutorStorageStatus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Return information about blocks stored in all of the slaves</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getLocalProperty(java.lang.String)">getLocalProperty</A></B>(String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a local property set in this thread, or null if it is missing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getOrCreate()">getOrCreate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function may be used to get or instantiate a SparkContext and register it as a
 singleton object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getOrCreate(org.apache.spark.SparkConf)">getOrCreate</A></B>(<A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;config)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function may be used to get or instantiate a SparkContext and register it as a
 singleton object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.collection.Map&lt;Object,<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;?&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getPersistentRDDs()">getPersistentRDDs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable map of RDDs that have marked themselves as persistent via cache() call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.Option&lt;org.apache.spark.scheduler.Schedulable&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getPoolForName(java.lang.String)">getPoolForName</A></B>(String&nbsp;pool)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Return the pool associated with the given name, if one exists</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/apache/spark/storage/RDDInfo.html" title="class in org.apache.spark.storage">RDDInfo</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getRDDStorageInfo()">getRDDStorageInfo</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Return information about what RDDs are cached, if they are in mem or on disk, how much space
 they take, etc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.Enumeration.Value</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#getSchedulingMode()">getSchedulingMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return current scheduling mode</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.apache.hadoop.conf.Configuration</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#hadoopConfiguration()">hadoopConfiguration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A default Hadoop Configuration for the Hadoop code (e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#hadoopFile(java.lang.String, java.lang.Class, java.lang.Class, java.lang.Class, int)">hadoopFile</A></B>(String&nbsp;path,
           Class&lt;? extends org.apache.hadoop.mapred.InputFormat&lt;K,V&gt;&gt;&nbsp;inputFormatClass,
           Class&lt;K&gt;&nbsp;keyClass,
           Class&lt;V&gt;&nbsp;valueClass,
           int&nbsp;minPartitions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an RDD for a Hadoop file with an arbitrary InputFormat</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V,F extends org.apache.hadoop.mapred.InputFormat&lt;K,V&gt;&gt; 
<BR>
<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#hadoopFile(java.lang.String, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">hadoopFile</A></B>(String&nbsp;path,
           scala.reflect.ClassTag&lt;K&gt;&nbsp;km,
           scala.reflect.ClassTag&lt;V&gt;&nbsp;vm,
           scala.reflect.ClassTag&lt;F&gt;&nbsp;fm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Smarter version of hadoopFile() that uses class tags to figure out the classes of keys,
 values and the InputFormat so that users don't need to pass them directly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V,F extends org.apache.hadoop.mapred.InputFormat&lt;K,V&gt;&gt; 
<BR>
<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#hadoopFile(java.lang.String, int, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">hadoopFile</A></B>(String&nbsp;path,
           int&nbsp;minPartitions,
           scala.reflect.ClassTag&lt;K&gt;&nbsp;km,
           scala.reflect.ClassTag&lt;V&gt;&nbsp;vm,
           scala.reflect.ClassTag&lt;F&gt;&nbsp;fm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Smarter version of hadoopFile() that uses class tags to figure out the classes of keys,
 values and the InputFormat so that users don't need to pass them directly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#hadoopRDD(org.apache.hadoop.mapred.JobConf, java.lang.Class, java.lang.Class, java.lang.Class, int)">hadoopRDD</A></B>(org.apache.hadoop.mapred.JobConf&nbsp;conf,
          Class&lt;? extends org.apache.hadoop.mapred.InputFormat&lt;K,V&gt;&gt;&nbsp;inputFormatClass,
          Class&lt;K&gt;&nbsp;keyClass,
          Class&lt;V&gt;&nbsp;valueClass,
          int&nbsp;minPartitions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an RDD for a Hadoop-readable dataset from a Hadoop JobConf given its InputFormat and other
 necessary info (e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#initLocalProperties()">initLocalProperties</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.hadoop.io.IntWritable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#intToIntWritable(int)">intToIntWritable</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.spark.WritableConverter&lt;Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#intWritableConverter()">intWritableConverter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#isLocal()">isLocal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;scala.Option&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#jarOfClass(java.lang.Class)">jarOfClass</A></B>(Class&lt;?&gt;&nbsp;cls)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the JAR from which a given class was loaded, to make it easy for users to pass
 their JARs to SparkContext.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;scala.Option&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#jarOfObject(java.lang.Object)">jarOfObject</A></B>(Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the JAR that contains the class of a particular object, to make it easy for users
 to pass their JARs to SparkContext.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.collection.Seq&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#jars()">jars</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#killExecutor(java.lang.String)">killExecutor</A></B>(String&nbsp;executorId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Request that cluster manager the kill the specified executor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#killExecutors(scala.collection.Seq)">killExecutors</A></B>(scala.collection.Seq&lt;String&gt;&nbsp;executorIds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Request that the cluster manager kill the specified executors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#LEGACY_DRIVER_IDENTIFIER()">LEGACY_DRIVER_IDENTIFIER</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Legacy version of DRIVER_IDENTIFIER, retained for backwards-compatibility.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.apache.spark.scheduler.LiveListenerBus</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#listenerBus()">listenerBus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.hadoop.io.LongWritable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#longToLongWritable(long)">longToLongWritable</A></B>(long&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.spark.WritableConverter&lt;Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#longWritableConverter()">longWritableConverter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#makeRDD(scala.collection.Seq, int, scala.reflect.ClassTag)">makeRDD</A></B>(scala.collection.Seq&lt;T&gt;&nbsp;seq,
        int&nbsp;numSlices,
        scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distribute a local Scala collection to form an RDD.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#makeRDD(scala.collection.Seq, scala.reflect.ClassTag)">makeRDD</A></B>(scala.collection.Seq&lt;scala.Tuple2&lt;T,scala.collection.Seq&lt;String&gt;&gt;&gt;&nbsp;seq,
        scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distribute a local Scala collection to form an RDD, with one or more
 location preferences (hostnames of Spark nodes) for each object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#master()">master</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.apache.spark.metrics.MetricsSystem</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#metricsSystem()">metricsSystem</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; 
<BR>
<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#newAPIHadoopFile(java.lang.String, java.lang.Class, java.lang.Class, java.lang.Class, org.apache.hadoop.conf.Configuration)">newAPIHadoopFile</A></B>(String&nbsp;path,
                 Class&lt;F&gt;&nbsp;fClass,
                 Class&lt;K&gt;&nbsp;kClass,
                 Class&lt;V&gt;&nbsp;vClass,
                 org.apache.hadoop.conf.Configuration&nbsp;conf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an RDD for a given Hadoop file with an arbitrary new API InputFormat
 and extra configuration options to pass to the input format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; 
<BR>
<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#newAPIHadoopFile(java.lang.String, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">newAPIHadoopFile</A></B>(String&nbsp;path,
                 scala.reflect.ClassTag&lt;K&gt;&nbsp;km,
                 scala.reflect.ClassTag&lt;V&gt;&nbsp;vm,
                 scala.reflect.ClassTag&lt;F&gt;&nbsp;fm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an RDD for a Hadoop file with an arbitrary new API InputFormat.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; 
<BR>
<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#newAPIHadoopRDD(org.apache.hadoop.conf.Configuration, java.lang.Class, java.lang.Class, java.lang.Class)">newAPIHadoopRDD</A></B>(org.apache.hadoop.conf.Configuration&nbsp;conf,
                Class&lt;F&gt;&nbsp;fClass,
                Class&lt;K&gt;&nbsp;kClass,
                Class&lt;V&gt;&nbsp;vClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an RDD for a given Hadoop file with an arbitrary new API InputFormat
 and extra configuration options to pass to the input format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/rdd/DoubleRDDFunctions.html" title="class in org.apache.spark.rdd">DoubleRDDFunctions</A></CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#numericRDDToDoubleRDDFunctions(org.apache.spark.rdd.RDD, scala.math.Numeric)">numericRDDToDoubleRDDFunctions</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                               scala.math.Numeric&lt;T&gt;&nbsp;num)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#objectFile(java.lang.String, int, scala.reflect.ClassTag)">objectFile</A></B>(String&nbsp;path,
           int&nbsp;minPartitions,
           scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Load an RDD saved as a SequenceFile containing serialized objects, with NullWritable keys and
 BytesWritable values that contain a serialized partition.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#parallelize(scala.collection.Seq, int, scala.reflect.ClassTag)">parallelize</A></B>(scala.collection.Seq&lt;T&gt;&nbsp;seq,
            int&nbsp;numSlices,
            scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distribute a local Scala collection to form an RDD.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<any></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#persistentRdds()">persistentRdds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.collection.Map&lt;String,scala.collection.Set&lt;<A HREF="../../../org/apache/spark/scheduler/SplitInfo.html" title="class in org.apache.spark.scheduler">SplitInfo</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#preferredNodeLocationData()">preferredNodeLocationData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#range(long, long, long, int)">range</A></B>(long&nbsp;start,
      long&nbsp;end,
      long&nbsp;step,
      int&nbsp;numSlices)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new RDD[Long] containing elements from <code>start</code> to <code>end</code>(exclusive), increased by
 <code>step</code> every element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#RDD_SCOPE_KEY()">RDD_SCOPE_KEY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#RDD_SCOPE_NO_OVERRIDE_KEY()">RDD_SCOPE_NO_OVERRIDE_KEY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/rdd/AsyncRDDActions.html" title="class in org.apache.spark.rdd">AsyncRDDActions</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#rddToAsyncRDDActions(org.apache.spark.rdd.RDD, scala.reflect.ClassTag)">rddToAsyncRDDActions</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                     scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$19)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/OrderedRDDFunctions.html" title="class in org.apache.spark.rdd">OrderedRDDFunctions</A>&lt;K,V,scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#rddToOrderedRDDFunctions(org.apache.spark.rdd.RDD, scala.math.Ordering, scala.reflect.ClassTag, scala.reflect.ClassTag)">rddToOrderedRDDFunctions</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;rdd,
                         scala.math.Ordering&lt;K&gt;&nbsp;evidence$24,
                         scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$25,
                         scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$26)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/PairRDDFunctions.html" title="class in org.apache.spark.rdd">PairRDDFunctions</A>&lt;K,V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#rddToPairRDDFunctions(org.apache.spark.rdd.RDD, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.math.Ordering)">rddToPairRDDFunctions</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;rdd,
                      scala.reflect.ClassTag&lt;K&gt;&nbsp;kt,
                      scala.reflect.ClassTag&lt;V&gt;&nbsp;vt,
                      scala.math.Ordering&lt;K&gt;&nbsp;ord)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/SequenceFileRDDFunctions.html" title="class in org.apache.spark.rdd">SequenceFileRDDFunctions</A>&lt;K,V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#rddToSequenceFileRDDFunctions(org.apache.spark.rdd.RDD, scala.Function1, scala.reflect.ClassTag, scala.Function1, scala.reflect.ClassTag)">rddToSequenceFileRDDFunctions</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;rdd,
                              scala.Function1&lt;K,org.apache.hadoop.io.Writable&gt;&nbsp;evidence$20,
                              scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$21,
                              scala.Function1&lt;V,org.apache.hadoop.io.Writable&gt;&nbsp;evidence$22,
                              scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$23)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#requestExecutors(int)">requestExecutors</A></B>(int&nbsp;numAdditionalExecutors)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Request an additional number of executors from the cluster manager.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,U,R&gt; <A HREF="../../../org/apache/spark/partial/PartialResult.html" title="class in org.apache.spark.partial">PartialResult</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#runApproximateJob(org.apache.spark.rdd.RDD, scala.Function2, , long)">runApproximateJob</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                  scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
                  <any>&nbsp;evaluator,
                  long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::
 Run a job that can return approximate results.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,U&gt; Object</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#runJob(org.apache.spark.rdd.RDD, scala.Function1, scala.reflect.ClassTag)">runJob</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
       scala.Function1&lt;scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
       scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$16)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run a job on all partitions in an RDD and return the results in an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,U&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#runJob(org.apache.spark.rdd.RDD, scala.Function1, scala.Function2, scala.reflect.ClassTag)">runJob</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
       scala.Function1&lt;scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;processPartition,
       scala.Function2&lt;Object,U,scala.runtime.BoxedUnit&gt;&nbsp;resultHandler,
       scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$18)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run a job on all partitions in an RDD and pass the results to a handler function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,U&gt; Object</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#runJob(org.apache.spark.rdd.RDD, scala.Function1, scala.collection.Seq, boolean, scala.reflect.ClassTag)">runJob</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
       scala.Function1&lt;scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
       scala.collection.Seq&lt;Object&gt;&nbsp;partitions,
       boolean&nbsp;allowLocal,
       scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$14)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run a job on a given set of partitions of an RDD, but take a function of type
 <code>Iterator[T] =&gt; U</code> instead of <code>(TaskContext, Iterator[T]) =&gt; U</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,U&gt; Object</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#runJob(org.apache.spark.rdd.RDD, scala.Function2, scala.reflect.ClassTag)">runJob</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
       scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
       scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$15)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run a job on all partitions in an RDD and return the results in an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,U&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#runJob(org.apache.spark.rdd.RDD, scala.Function2, scala.Function2, scala.reflect.ClassTag)">runJob</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
       scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;processPartition,
       scala.Function2&lt;Object,U,scala.runtime.BoxedUnit&gt;&nbsp;resultHandler,
       scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$17)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run a job on all partitions in an RDD and pass the results to a handler function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,U&gt; Object</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#runJob(org.apache.spark.rdd.RDD, scala.Function2, scala.collection.Seq, boolean, scala.reflect.ClassTag)">runJob</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
       scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
       scala.collection.Seq&lt;Object&gt;&nbsp;partitions,
       boolean&nbsp;allowLocal,
       scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$13)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run a function on a given set of partitions in an RDD and return the results as an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,U&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#runJob(org.apache.spark.rdd.RDD, scala.Function2, scala.collection.Seq, boolean, scala.Function2, scala.reflect.ClassTag)">runJob</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
       scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
       scala.collection.Seq&lt;Object&gt;&nbsp;partitions,
       boolean&nbsp;allowLocal,
       scala.Function2&lt;Object,U,scala.runtime.BoxedUnit&gt;&nbsp;resultHandler,
       scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$12)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run a function on a given set of partitions in an RDD and pass the results to the given
 handler function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#sequenceFile(java.lang.String, java.lang.Class, java.lang.Class)">sequenceFile</A></B>(String&nbsp;path,
             Class&lt;K&gt;&nbsp;keyClass,
             Class&lt;V&gt;&nbsp;valueClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an RDD for a Hadoop SequenceFile with given key and value types.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#sequenceFile(java.lang.String, java.lang.Class, java.lang.Class, int)">sequenceFile</A></B>(String&nbsp;path,
             Class&lt;K&gt;&nbsp;keyClass,
             Class&lt;V&gt;&nbsp;valueClass,
             int&nbsp;minPartitions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get an RDD for a Hadoop SequenceFile with given key and value types.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#sequenceFile(java.lang.String, int, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.Function0, scala.Function0)">sequenceFile</A></B>(String&nbsp;path,
             int&nbsp;minPartitions,
             scala.reflect.ClassTag&lt;K&gt;&nbsp;km,
             scala.reflect.ClassTag&lt;V&gt;&nbsp;vm,
             scala.Function0&lt;org.apache.spark.WritableConverter&lt;K&gt;&gt;&nbsp;kcf,
             scala.Function0&lt;org.apache.spark.WritableConverter&lt;V&gt;&gt;&nbsp;vcf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Version of sequenceFile() for types implicitly convertible to Writables through a
 WritableConverter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#setCallSite(java.lang.String)">setCallSite</A></B>(String&nbsp;shortCallSite)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the thread-local property for overriding the call sites
 of actions and RDDs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#setCheckpointDir(java.lang.String)">setCheckpointDir</A></B>(String&nbsp;directory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the directory under which RDDs are going to be checkpointed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#setJobDescription(java.lang.String)">setJobDescription</A></B>(String&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a human readable description of the current job.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#setJobGroup(java.lang.String, java.lang.String, boolean)">setJobGroup</A></B>(String&nbsp;groupId,
            String&nbsp;description,
            boolean&nbsp;interruptOnCancel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assigns a group ID to all the jobs started by this thread until the group ID is set to a
 different value or cleared.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#setLocalProperty(java.lang.String, java.lang.String)">setLocalProperty</A></B>(String&nbsp;key,
                 String&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a local property that affects jobs submitted from this thread, such as the
 Spark fair scheduler pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#setLogLevel(java.lang.String)">setLogLevel</A></B>(String&nbsp;logLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Control our logLevel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#SPARK_JOB_DESCRIPTION()">SPARK_JOB_DESCRIPTION</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#SPARK_JOB_GROUP_ID()">SPARK_JOB_GROUP_ID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#SPARK_JOB_INTERRUPT_ON_CANCEL()">SPARK_JOB_INTERRUPT_ON_CANCEL</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#sparkUser()">sparkUser</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#startTime()">startTime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/apache/spark/SparkStatusTracker.html" title="class in org.apache.spark">SparkStatusTracker</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#statusTracker()">statusTracker</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#stop()">stop</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.hadoop.io.Text</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#stringToText(java.lang.String)">stringToText</A></B>(String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.apache.spark.WritableConverter&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#stringWritableConverter()">stringWritableConverter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,U,R&gt; <A HREF="../../../org/apache/spark/SimpleFutureAction.html" title="class in org.apache.spark">SimpleFutureAction</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#submitJob(org.apache.spark.rdd.RDD, scala.Function1, scala.collection.Seq, scala.Function2, scala.Function0)">submitJob</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
          scala.Function1&lt;scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;processPartition,
          scala.collection.Seq&lt;Object&gt;&nbsp;partitions,
          scala.Function2&lt;Object,U,scala.runtime.BoxedUnit&gt;&nbsp;resultHandler,
          scala.Function0&lt;R&gt;&nbsp;resultFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Experimental ::
 Submit a job for execution and return a FutureJob holding the result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#tachyonFolderName()">tachyonFolderName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#textFile(java.lang.String, int)">textFile</A></B>(String&nbsp;path,
         int&nbsp;minPartitions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read a text file from HDFS, a local file system (available on all nodes), or any
 Hadoop-supported file system URI, and return it as an RDD of Strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#union(org.apache.spark.rdd.RDD, scala.collection.Seq, scala.reflect.ClassTag)">union</A></B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;first,
      scala.collection.Seq&lt;<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;rest,
      scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$7)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Build the union of a list of RDDs passed as variable-length arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#union(scala.collection.Seq, scala.reflect.ClassTag)">union</A></B>(scala.collection.Seq&lt;<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;rdds,
      scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$6)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Build the union of a list of RDDs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#version()">version</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The version of Spark on which this application is running.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;String,String&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#wholeTextFiles(java.lang.String, int)">wholeTextFiles</A></B>(String&nbsp;path,
               int&nbsp;minPartitions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read a directory of text files from HDFS, a local file system (available on all nodes), or any
 Hadoop-supported file system URI.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends org.apache.hadoop.io.Writable&gt; 
<BR>
org.apache.spark.WritableConverter&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/apache/spark/SparkContext.html#writableWritableConverter()">writableWritableConverter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.apache.spark.Logging"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface org.apache.spark.<A HREF="../../../org/apache/spark/Logging.html" title="interface in org.apache.spark">Logging</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/apache/spark/Logging.html#initializeIfNecessary()">initializeIfNecessary</A>, <A HREF="../../../org/apache/spark/Logging.html#initializeLogging()">initializeLogging</A>, <A HREF="../../../org/apache/spark/Logging.html#isTraceEnabled()">isTraceEnabled</A>, <A HREF="../../../org/apache/spark/Logging.html#log_()">log_</A>, <A HREF="../../../org/apache/spark/Logging.html#log()">log</A>, <A HREF="../../../org/apache/spark/Logging.html#logDebug(scala.Function0)">logDebug</A>, <A HREF="../../../org/apache/spark/Logging.html#logDebug(scala.Function0, java.lang.Throwable)">logDebug</A>, <A HREF="../../../org/apache/spark/Logging.html#logError(scala.Function0)">logError</A>, <A HREF="../../../org/apache/spark/Logging.html#logError(scala.Function0, java.lang.Throwable)">logError</A>, <A HREF="../../../org/apache/spark/Logging.html#logInfo(scala.Function0)">logInfo</A>, <A HREF="../../../org/apache/spark/Logging.html#logInfo(scala.Function0, java.lang.Throwable)">logInfo</A>, <A HREF="../../../org/apache/spark/Logging.html#logName()">logName</A>, <A HREF="../../../org/apache/spark/Logging.html#logTrace(scala.Function0)">logTrace</A>, <A HREF="../../../org/apache/spark/Logging.html#logTrace(scala.Function0, java.lang.Throwable)">logTrace</A>, <A HREF="../../../org/apache/spark/Logging.html#logWarning(scala.Function0)">logWarning</A>, <A HREF="../../../org/apache/spark/Logging.html#logWarning(scala.Function0, java.lang.Throwable)">logWarning</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SparkContext(org.apache.spark.SparkConf)"><!-- --></A><H3>
SparkContext</H3>
<PRE>
public <B>SparkContext</B>(<A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;config)</PRE>
<DL>
</DL>
<HR>

<A NAME="SparkContext()"><!-- --></A><H3>
SparkContext</H3>
<PRE>
public <B>SparkContext</B>()</PRE>
<DL>
<DD>Create a SparkContext that loads settings from system properties (for instance, when
 launching with ./bin/spark-submit).
<P>
</DL>
<HR>

<A NAME="SparkContext(org.apache.spark.SparkConf, scala.collection.Map)"><!-- --></A><H3>
SparkContext</H3>
<PRE>
public <B>SparkContext</B>(<A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;config,
                    scala.collection.Map&lt;String,scala.collection.Set&lt;<A HREF="../../../org/apache/spark/scheduler/SplitInfo.html" title="class in org.apache.spark.scheduler">SplitInfo</A>&gt;&gt;&nbsp;preferredNodeLocationData)</PRE>
<DL>
<DD>:: DeveloperApi ::
 Alternative constructor for setting preferred locations where Spark will create executors.
 <p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>preferredNodeLocationData</CODE> - used in YARN mode to select nodes to launch containers on.
 Can be generated using <CODE>org.apache.spark.scheduler.InputFormatInfo.computePreferredLocations</CODE>
 from a list of input files or InputFormats for the application.<DD><CODE>config</CODE> - (undocumented)</DL>
</DL>
<HR>

<A NAME="SparkContext(java.lang.String, java.lang.String, org.apache.spark.SparkConf)"><!-- --></A><H3>
SparkContext</H3>
<PRE>
public <B>SparkContext</B>(String&nbsp;master,
                    String&nbsp;appName,
                    <A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;conf)</PRE>
<DL>
<DD>Alternative constructor that allows setting common Spark properties directly
 <p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>master</CODE> - Cluster URL to connect to (e.g. mesos://host:port, spark://host:port, local[4]).<DD><CODE>appName</CODE> - A name for your application, to display on the cluster web UI<DD><CODE>conf</CODE> - a <A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark"><CODE>SparkConf</CODE></A> object specifying other Spark parameters</DL>
</DL>
<HR>

<A NAME="SparkContext(java.lang.String, java.lang.String, java.lang.String, scala.collection.Seq, scala.collection.Map, scala.collection.Map)"><!-- --></A><H3>
SparkContext</H3>
<PRE>
public <B>SparkContext</B>(String&nbsp;master,
                    String&nbsp;appName,
                    String&nbsp;sparkHome,
                    scala.collection.Seq&lt;String&gt;&nbsp;jars,
                    scala.collection.Map&lt;String,String&gt;&nbsp;environment,
                    scala.collection.Map&lt;String,scala.collection.Set&lt;<A HREF="../../../org/apache/spark/scheduler/SplitInfo.html" title="class in org.apache.spark.scheduler">SplitInfo</A>&gt;&gt;&nbsp;preferredNodeLocationData)</PRE>
<DL>
<DD>Alternative constructor that allows setting common Spark properties directly
 <p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>master</CODE> - Cluster URL to connect to (e.g. mesos://host:port, spark://host:port, local[4]).<DD><CODE>appName</CODE> - A name for your application, to display on the cluster web UI.<DD><CODE>sparkHome</CODE> - Location where Spark is installed on cluster nodes.<DD><CODE>jars</CODE> - Collection of JARs to send to the cluster. These can be paths on the local file
             system or HDFS, HTTP, HTTPS, or FTP URLs.<DD><CODE>environment</CODE> - Environment variables to set on worker nodes.<DD><CODE>preferredNodeLocationData</CODE> - (undocumented)</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getOrCreate(org.apache.spark.SparkConf)"><!-- --></A><H3>
getOrCreate</H3>
<PRE>
public static <A HREF="../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A> <B>getOrCreate</B>(<A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;config)</PRE>
<DL>
<DD>This function may be used to get or instantiate a SparkContext and register it as a
 singleton object. Because we can only have one active SparkContext per JVM,
 this is useful when applications may wish to share a SparkContext.
 <p>
 Note: This function cannot be used to create multiple SparkContext instances
 even if multiple contexts are allowed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>config</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getOrCreate()"><!-- --></A><H3>
getOrCreate</H3>
<PRE>
public static <A HREF="../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A> <B>getOrCreate</B>()</PRE>
<DL>
<DD>This function may be used to get or instantiate a SparkContext and register it as a
 singleton object. Because we can only have one active SparkContext per JVM,
 this is useful when applications may wish to share a SparkContext.
 <p>
 This method allows not passing a SparkConf (useful if just retrieving).
 <p>
 Note: This function cannot be used to create multiple SparkContext instances
 even if multiple contexts are allowed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="SPARK_JOB_DESCRIPTION()"><!-- --></A><H3>
SPARK_JOB_DESCRIPTION</H3>
<PRE>
public static String <B>SPARK_JOB_DESCRIPTION</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="SPARK_JOB_GROUP_ID()"><!-- --></A><H3>
SPARK_JOB_GROUP_ID</H3>
<PRE>
public static String <B>SPARK_JOB_GROUP_ID</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="SPARK_JOB_INTERRUPT_ON_CANCEL()"><!-- --></A><H3>
SPARK_JOB_INTERRUPT_ON_CANCEL</H3>
<PRE>
public static String <B>SPARK_JOB_INTERRUPT_ON_CANCEL</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="RDD_SCOPE_KEY()"><!-- --></A><H3>
RDD_SCOPE_KEY</H3>
<PRE>
public static String <B>RDD_SCOPE_KEY</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="RDD_SCOPE_NO_OVERRIDE_KEY()"><!-- --></A><H3>
RDD_SCOPE_NO_OVERRIDE_KEY</H3>
<PRE>
public static String <B>RDD_SCOPE_NO_OVERRIDE_KEY</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="DRIVER_IDENTIFIER()"><!-- --></A><H3>
DRIVER_IDENTIFIER</H3>
<PRE>
public static String <B>DRIVER_IDENTIFIER</B>()</PRE>
<DL>
<DD>Executor id for the driver.  In earlier versions of Spark, this was <code><driver></code>, but this was
 changed to <code>driver</code> because the angle brackets caused escaping issues in URLs and XML (see
 SPARK-6716 for more details).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="LEGACY_DRIVER_IDENTIFIER()"><!-- --></A><H3>
LEGACY_DRIVER_IDENTIFIER</H3>
<PRE>
public static String <B>LEGACY_DRIVER_IDENTIFIER</B>()</PRE>
<DL>
<DD>Legacy version of DRIVER_IDENTIFIER, retained for backwards-compatibility.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="rddToPairRDDFunctions(org.apache.spark.rdd.RDD, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.math.Ordering)"><!-- --></A><H3>
rddToPairRDDFunctions</H3>
<PRE>
public static &lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/PairRDDFunctions.html" title="class in org.apache.spark.rdd">PairRDDFunctions</A>&lt;K,V&gt; <B>rddToPairRDDFunctions</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;rdd,
                                                                scala.reflect.ClassTag&lt;K&gt;&nbsp;kt,
                                                                scala.reflect.ClassTag&lt;V&gt;&nbsp;vt,
                                                                scala.math.Ordering&lt;K&gt;&nbsp;ord)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rddToAsyncRDDActions(org.apache.spark.rdd.RDD, scala.reflect.ClassTag)"><!-- --></A><H3>
rddToAsyncRDDActions</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../../org/apache/spark/rdd/AsyncRDDActions.html" title="class in org.apache.spark.rdd">AsyncRDDActions</A>&lt;T&gt; <B>rddToAsyncRDDActions</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                                                          scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$19)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rddToSequenceFileRDDFunctions(org.apache.spark.rdd.RDD, scala.Function1, scala.reflect.ClassTag, scala.Function1, scala.reflect.ClassTag)"><!-- --></A><H3>
rddToSequenceFileRDDFunctions</H3>
<PRE>
public static &lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/SequenceFileRDDFunctions.html" title="class in org.apache.spark.rdd">SequenceFileRDDFunctions</A>&lt;K,V&gt; <B>rddToSequenceFileRDDFunctions</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;rdd,
                                                                                scala.Function1&lt;K,org.apache.hadoop.io.Writable&gt;&nbsp;evidence$20,
                                                                                scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$21,
                                                                                scala.Function1&lt;V,org.apache.hadoop.io.Writable&gt;&nbsp;evidence$22,
                                                                                scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$23)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rddToOrderedRDDFunctions(org.apache.spark.rdd.RDD, scala.math.Ordering, scala.reflect.ClassTag, scala.reflect.ClassTag)"><!-- --></A><H3>
rddToOrderedRDDFunctions</H3>
<PRE>
public static &lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/OrderedRDDFunctions.html" title="class in org.apache.spark.rdd">OrderedRDDFunctions</A>&lt;K,V,scala.Tuple2&lt;K,V&gt;&gt; <B>rddToOrderedRDDFunctions</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;rdd,
                                                                                        scala.math.Ordering&lt;K&gt;&nbsp;evidence$24,
                                                                                        scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$25,
                                                                                        scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$26)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="doubleRDDToDoubleRDDFunctions(org.apache.spark.rdd.RDD)"><!-- --></A><H3>
doubleRDDToDoubleRDDFunctions</H3>
<PRE>
public static <A HREF="../../../org/apache/spark/rdd/DoubleRDDFunctions.html" title="class in org.apache.spark.rdd">DoubleRDDFunctions</A> <B>doubleRDDToDoubleRDDFunctions</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;Object&gt;&nbsp;rdd)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="numericRDDToDoubleRDDFunctions(org.apache.spark.rdd.RDD, scala.math.Numeric)"><!-- --></A><H3>
numericRDDToDoubleRDDFunctions</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../../org/apache/spark/rdd/DoubleRDDFunctions.html" title="class in org.apache.spark.rdd">DoubleRDDFunctions</A> <B>numericRDDToDoubleRDDFunctions</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                                                                    scala.math.Numeric&lt;T&gt;&nbsp;num)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="intToIntWritable(int)"><!-- --></A><H3>
intToIntWritable</H3>
<PRE>
public static org.apache.hadoop.io.IntWritable <B>intToIntWritable</B>(int&nbsp;i)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="longToLongWritable(long)"><!-- --></A><H3>
longToLongWritable</H3>
<PRE>
public static org.apache.hadoop.io.LongWritable <B>longToLongWritable</B>(long&nbsp;l)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="floatToFloatWritable(float)"><!-- --></A><H3>
floatToFloatWritable</H3>
<PRE>
public static org.apache.hadoop.io.FloatWritable <B>floatToFloatWritable</B>(float&nbsp;f)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="doubleToDoubleWritable(double)"><!-- --></A><H3>
doubleToDoubleWritable</H3>
<PRE>
public static org.apache.hadoop.io.DoubleWritable <B>doubleToDoubleWritable</B>(double&nbsp;d)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="boolToBoolWritable(boolean)"><!-- --></A><H3>
boolToBoolWritable</H3>
<PRE>
public static org.apache.hadoop.io.BooleanWritable <B>boolToBoolWritable</B>(boolean&nbsp;b)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="bytesToBytesWritable(byte[])"><!-- --></A><H3>
bytesToBytesWritable</H3>
<PRE>
public static org.apache.hadoop.io.BytesWritable <B>bytesToBytesWritable</B>(byte[]&nbsp;aob)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="stringToText(java.lang.String)"><!-- --></A><H3>
stringToText</H3>
<PRE>
public static org.apache.hadoop.io.Text <B>stringToText</B>(String&nbsp;s)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="intWritableConverter()"><!-- --></A><H3>
intWritableConverter</H3>
<PRE>
public static org.apache.spark.WritableConverter&lt;Object&gt; <B>intWritableConverter</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="longWritableConverter()"><!-- --></A><H3>
longWritableConverter</H3>
<PRE>
public static org.apache.spark.WritableConverter&lt;Object&gt; <B>longWritableConverter</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="doubleWritableConverter()"><!-- --></A><H3>
doubleWritableConverter</H3>
<PRE>
public static org.apache.spark.WritableConverter&lt;Object&gt; <B>doubleWritableConverter</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="floatWritableConverter()"><!-- --></A><H3>
floatWritableConverter</H3>
<PRE>
public static org.apache.spark.WritableConverter&lt;Object&gt; <B>floatWritableConverter</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="booleanWritableConverter()"><!-- --></A><H3>
booleanWritableConverter</H3>
<PRE>
public static org.apache.spark.WritableConverter&lt;Object&gt; <B>booleanWritableConverter</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="bytesWritableConverter()"><!-- --></A><H3>
bytesWritableConverter</H3>
<PRE>
public static org.apache.spark.WritableConverter&lt;byte[]&gt; <B>bytesWritableConverter</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="stringWritableConverter()"><!-- --></A><H3>
stringWritableConverter</H3>
<PRE>
public static org.apache.spark.WritableConverter&lt;String&gt; <B>stringWritableConverter</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="writableWritableConverter()"><!-- --></A><H3>
writableWritableConverter</H3>
<PRE>
public static &lt;T extends org.apache.hadoop.io.Writable&gt; org.apache.spark.WritableConverter&lt;T&gt; <B>writableWritableConverter</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="jarOfClass(java.lang.Class)"><!-- --></A><H3>
jarOfClass</H3>
<PRE>
public static scala.Option&lt;String&gt; <B>jarOfClass</B>(Class&lt;?&gt;&nbsp;cls)</PRE>
<DL>
<DD>Find the JAR from which a given class was loaded, to make it easy for users to pass
 their JARs to SparkContext.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cls</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="jarOfObject(java.lang.Object)"><!-- --></A><H3>
jarOfObject</H3>
<PRE>
public static scala.Option&lt;String&gt; <B>jarOfObject</B>(Object&nbsp;obj)</PRE>
<DL>
<DD>Find the JAR that contains the class of a particular object, to make it easy for users
 to pass their JARs to SparkContext. In most cases you can call jarOfObject(this) in
 your driver program.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="preferredNodeLocationData()"><!-- --></A><H3>
preferredNodeLocationData</H3>
<PRE>
public scala.collection.Map&lt;String,scala.collection.Set&lt;<A HREF="../../../org/apache/spark/scheduler/SplitInfo.html" title="class in org.apache.spark.scheduler">SplitInfo</A>&gt;&gt; <B>preferredNodeLocationData</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="startTime()"><!-- --></A><H3>
startTime</H3>
<PRE>
public long <B>startTime</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getConf()"><!-- --></A><H3>
getConf</H3>
<PRE>
public <A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A> <B>getConf</B>()</PRE>
<DL>
<DD>Return a copy of this SparkContext's configuration. The configuration ''cannot'' be
 changed at runtime.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="jars()"><!-- --></A><H3>
jars</H3>
<PRE>
public scala.collection.Seq&lt;String&gt; <B>jars</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="files()"><!-- --></A><H3>
files</H3>
<PRE>
public scala.collection.Seq&lt;String&gt; <B>files</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="master()"><!-- --></A><H3>
master</H3>
<PRE>
public String <B>master</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="appName()"><!-- --></A><H3>
appName</H3>
<PRE>
public String <B>appName</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="externalBlockStoreFolderName()"><!-- --></A><H3>
externalBlockStoreFolderName</H3>
<PRE>
public String <B>externalBlockStoreFolderName</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="tachyonFolderName()"><!-- --></A><H3>
tachyonFolderName</H3>
<PRE>
public String <B>tachyonFolderName</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isLocal()"><!-- --></A><H3>
isLocal</H3>
<PRE>
public boolean <B>isLocal</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="listenerBus()"><!-- --></A><H3>
listenerBus</H3>
<PRE>
public org.apache.spark.scheduler.LiveListenerBus <B>listenerBus</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addedFiles()"><!-- --></A><H3>
addedFiles</H3>
<PRE>
public scala.collection.mutable.HashMap&lt;String,Object&gt; <B>addedFiles</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addedJars()"><!-- --></A><H3>
addedJars</H3>
<PRE>
public scala.collection.mutable.HashMap&lt;String,Object&gt; <B>addedJars</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="persistentRdds()"><!-- --></A><H3>
persistentRdds</H3>
<PRE>
public <any> <B>persistentRdds</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="statusTracker()"><!-- --></A><H3>
statusTracker</H3>
<PRE>
public <A HREF="../../../org/apache/spark/SparkStatusTracker.html" title="class in org.apache.spark">SparkStatusTracker</A> <B>statusTracker</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hadoopConfiguration()"><!-- --></A><H3>
hadoopConfiguration</H3>
<PRE>
public org.apache.hadoop.conf.Configuration <B>hadoopConfiguration</B>()</PRE>
<DL>
<DD>A default Hadoop Configuration for the Hadoop code (e.g. file systems) that we reuse.
 <p>
 '''Note:''' As it will be reused in all Hadoop RDDs, it's better not to modify it unless you
 plan to set some global configurations for all Hadoop RDDs.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="executorEnvs()"><!-- --></A><H3>
executorEnvs</H3>
<PRE>
public scala.collection.mutable.HashMap&lt;String,String&gt; <B>executorEnvs</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sparkUser()"><!-- --></A><H3>
sparkUser</H3>
<PRE>
public String <B>sparkUser</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="applicationId()"><!-- --></A><H3>
applicationId</H3>
<PRE>
public String <B>applicationId</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="applicationAttemptId()"><!-- --></A><H3>
applicationAttemptId</H3>
<PRE>
public scala.Option&lt;String&gt; <B>applicationAttemptId</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="metricsSystem()"><!-- --></A><H3>
metricsSystem</H3>
<PRE>
public org.apache.spark.metrics.MetricsSystem <B>metricsSystem</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkpointDir()"><!-- --></A><H3>
checkpointDir</H3>
<PRE>
public scala.Option&lt;String&gt; <B>checkpointDir</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLogLevel(java.lang.String)"><!-- --></A><H3>
setLogLevel</H3>
<PRE>
public void <B>setLogLevel</B>(String&nbsp;logLevel)</PRE>
<DL>
<DD>Control our logLevel. This overrides any user-defined log settings.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logLevel</CODE> - The desired log level as a string.
 Valid log levels include: ALL, DEBUG, ERROR, FATAL, INFO, OFF, TRACE, WARN</DL>
</DD>
</DL>
<HR>

<A NAME="initLocalProperties()"><!-- --></A><H3>
initLocalProperties</H3>
<PRE>
public void <B>initLocalProperties</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLocalProperty(java.lang.String, java.lang.String)"><!-- --></A><H3>
setLocalProperty</H3>
<PRE>
public void <B>setLocalProperty</B>(String&nbsp;key,
                             String&nbsp;value)</PRE>
<DL>
<DD>Set a local property that affects jobs submitted from this thread, such as the
 Spark fair scheduler pool.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - (undocumented)<DD><CODE>value</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getLocalProperty(java.lang.String)"><!-- --></A><H3>
getLocalProperty</H3>
<PRE>
public String <B>getLocalProperty</B>(String&nbsp;key)</PRE>
<DL>
<DD>Get a local property set in this thread, or null if it is missing. See
 <CODE>org.apache.spark.SparkContext.setLocalProperty</CODE>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="setJobDescription(java.lang.String)"><!-- --></A><H3>
setJobDescription</H3>
<PRE>
public void <B>setJobDescription</B>(String&nbsp;value)</PRE>
<DL>
<DD>Set a human readable description of the current job.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setJobGroup(java.lang.String, java.lang.String, boolean)"><!-- --></A><H3>
setJobGroup</H3>
<PRE>
public void <B>setJobGroup</B>(String&nbsp;groupId,
                        String&nbsp;description,
                        boolean&nbsp;interruptOnCancel)</PRE>
<DL>
<DD>Assigns a group ID to all the jobs started by this thread until the group ID is set to a
 different value or cleared.
 <p>
 Often, a unit of execution in an application consists of multiple Spark actions or jobs.
 Application programmers can use this method to group all those jobs together and give a
 group description. Once set, the Spark web UI will associate such jobs with this group.
 <p>
 The application can also use <CODE>org.apache.spark.SparkContext.cancelJobGroup</CODE> to cancel all
 running jobs in this group. For example,
 <pre><code>
 // In the main thread:
 sc.setJobGroup("some_job_to_cancel", "some job description")
 sc.parallelize(1 to 10000, 2).map { i =&gt; Thread.sleep(10); i }.count()

 // In a separate thread:
 sc.cancelJobGroup("some_job_to_cancel")
 </code></pre>
 <p>
 If interruptOnCancel is set to true for the job group, then job cancellation will result
 in Thread.interrupt() being called on the job's executor threads. This is useful to help ensure
 that the tasks are actually stopped in a timely manner, but is off by default due to HDFS-1208,
 where HDFS may respond to Thread.interrupt() by marking nodes as dead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>groupId</CODE> - (undocumented)<DD><CODE>description</CODE> - (undocumented)<DD><CODE>interruptOnCancel</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="clearJobGroup()"><!-- --></A><H3>
clearJobGroup</H3>
<PRE>
public void <B>clearJobGroup</B>()</PRE>
<DL>
<DD>Clear the current thread's job group ID and its description.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="parallelize(scala.collection.Seq, int, scala.reflect.ClassTag)"><!-- --></A><H3>
parallelize</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt; <B>parallelize</B>(scala.collection.Seq&lt;T&gt;&nbsp;seq,
                              int&nbsp;numSlices,
                              scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$1)</PRE>
<DL>
<DD>Distribute a local Scala collection to form an RDD.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>seq</CODE> - (undocumented)<DD><CODE>numSlices</CODE> - (undocumented)<DD><CODE>evidence$1</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="range(long, long, long, int)"><!-- --></A><H3>
range</H3>
<PRE>
public <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;Object&gt; <B>range</B>(long&nbsp;start,
                         long&nbsp;end,
                         long&nbsp;step,
                         int&nbsp;numSlices)</PRE>
<DL>
<DD>Creates a new RDD[Long] containing elements from <code>start</code> to <code>end</code>(exclusive), increased by
 <code>step</code> every element.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - the start value.<DD><CODE>end</CODE> - the end value.<DD><CODE>step</CODE> - the incremental step<DD><CODE>numSlices</CODE> - the partition number of the new RDD.
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="makeRDD(scala.collection.Seq, int, scala.reflect.ClassTag)"><!-- --></A><H3>
makeRDD</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt; <B>makeRDD</B>(scala.collection.Seq&lt;T&gt;&nbsp;seq,
                          int&nbsp;numSlices,
                          scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$2)</PRE>
<DL>
<DD>Distribute a local Scala collection to form an RDD.
 <p>
 This method is identical to <code>parallelize</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>seq</CODE> - (undocumented)<DD><CODE>numSlices</CODE> - (undocumented)<DD><CODE>evidence$2</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="makeRDD(scala.collection.Seq, scala.reflect.ClassTag)"><!-- --></A><H3>
makeRDD</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt; <B>makeRDD</B>(scala.collection.Seq&lt;scala.Tuple2&lt;T,scala.collection.Seq&lt;String&gt;&gt;&gt;&nbsp;seq,
                          scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$3)</PRE>
<DL>
<DD>Distribute a local Scala collection to form an RDD, with one or more
 location preferences (hostnames of Spark nodes) for each object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>seq</CODE> - (undocumented)<DD><CODE>evidence$3</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)
 Create a new partition for each collection item.</DL>
</DD>
</DL>
<HR>

<A NAME="textFile(java.lang.String, int)"><!-- --></A><H3>
textFile</H3>
<PRE>
public <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;String&gt; <B>textFile</B>(String&nbsp;path,
                            int&nbsp;minPartitions)</PRE>
<DL>
<DD>Read a text file from HDFS, a local file system (available on all nodes), or any
 Hadoop-supported file system URI, and return it as an RDD of Strings.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>minPartitions</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="wholeTextFiles(java.lang.String, int)"><!-- --></A><H3>
wholeTextFiles</H3>
<PRE>
public <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;String,String&gt;&gt; <B>wholeTextFiles</B>(String&nbsp;path,
                                                       int&nbsp;minPartitions)</PRE>
<DL>
<DD>Read a directory of text files from HDFS, a local file system (available on all nodes), or any
 Hadoop-supported file system URI. Each file is read as a single record and returned in a
 key-value pair, where the key is the path of each file, the value is the content of each file.
 <p>
 <p> For example, if you have the following files:
 <pre><code>
   hdfs://a-hdfs-path/part-00000
   hdfs://a-hdfs-path/part-00001
   ...
   hdfs://a-hdfs-path/part-nnnnn
 </code></pre>
 <p>
 Do <code>val rdd = sparkContext.wholeTextFile("hdfs://a-hdfs-path")</code>,
 <p>
 <p> then <code>rdd</code> contains
 <pre><code>
   (a-hdfs-path/part-00000, its content)
   (a-hdfs-path/part-00001, its content)
   ...
   (a-hdfs-path/part-nnnnn, its content)
 </code></pre>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>minPartitions</CODE> - A suggestion value of the minimal splitting number for input data.<DD><CODE>path</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="binaryFiles(java.lang.String, int)"><!-- --></A><H3>
binaryFiles</H3>
<PRE>
public <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;String,<A HREF="../../../org/apache/spark/input/PortableDataStream.html" title="class in org.apache.spark.input">PortableDataStream</A>&gt;&gt; <B>binaryFiles</B>(String&nbsp;path,
                                                                int&nbsp;minPartitions)</PRE>
<DL>
<DD>:: Experimental ::
 <p>
 Get an RDD for a Hadoop-readable dataset as PortableDataStream for each file
 (useful for binary data)
 <p>
 For example, if you have the following files:
 <pre><code>
   hdfs://a-hdfs-path/part-00000
   hdfs://a-hdfs-path/part-00001
   ...
   hdfs://a-hdfs-path/part-nnnnn
 </code></pre>
 <p>
 Do
 <code>val rdd = sparkContext.dataStreamFiles("hdfs://a-hdfs-path")</code>,
 <p>
 then <code>rdd</code> contains
 <pre><code>
   (a-hdfs-path/part-00000, its content)
   (a-hdfs-path/part-00001, its content)
   ...
   (a-hdfs-path/part-nnnnn, its content)
 </code></pre>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>minPartitions</CODE> - A suggestion value of the minimal splitting number for input data.<DD><CODE>path</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="binaryRecords(java.lang.String, int, org.apache.hadoop.conf.Configuration)"><!-- --></A><H3>
binaryRecords</H3>
<PRE>
public <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;byte[]&gt; <B>binaryRecords</B>(String&nbsp;path,
                                 int&nbsp;recordLength,
                                 org.apache.hadoop.conf.Configuration&nbsp;conf)</PRE>
<DL>
<DD>:: Experimental ::
 <p>
 Load data from a flat binary file, assuming the length of each record is constant.
 <p>
 '''Note:''' We ensure that the byte array for each record in the resulting RDD
 has the provided record length.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - Directory to the input data files<DD><CODE>recordLength</CODE> - The length at which to split the records<DD><CODE>conf</CODE> - (undocumented)
<DT><B>Returns:</B><DD>An RDD of data with values, represented as byte arrays</DL>
</DD>
</DL>
<HR>

<A NAME="hadoopRDD(org.apache.hadoop.mapred.JobConf, java.lang.Class, java.lang.Class, java.lang.Class, int)"><!-- --></A><H3>
hadoopRDD</H3>
<PRE>
public &lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>hadoopRDD</B>(org.apache.hadoop.mapred.JobConf&nbsp;conf,
                                              Class&lt;? extends org.apache.hadoop.mapred.InputFormat&lt;K,V&gt;&gt;&nbsp;inputFormatClass,
                                              Class&lt;K&gt;&nbsp;keyClass,
                                              Class&lt;V&gt;&nbsp;valueClass,
                                              int&nbsp;minPartitions)</PRE>
<DL>
<DD>Get an RDD for a Hadoop-readable dataset from a Hadoop JobConf given its InputFormat and other
 necessary info (e.g. file name for a filesystem-based dataset, table name for HyperTable),
 using the older MapReduce API (<code>org.apache.hadoop.mapred</code>).
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conf</CODE> - JobConf for setting up the dataset. Note: This will be put into a Broadcast.
             Therefore if you plan to reuse this conf to create multiple RDDs, you need to make
             sure you won't modify the conf. A safe approach is always creating a new conf for
             a new RDD.<DD><CODE>inputFormatClass</CODE> - Class of the InputFormat<DD><CODE>keyClass</CODE> - Class of the keys<DD><CODE>valueClass</CODE> - Class of the values<DD><CODE>minPartitions</CODE> - Minimum number of Hadoop Splits to generate.
 <p>
 '''Note:''' Because Hadoop's RecordReader class re-uses the same Writable object for each
 record, directly caching the returned RDD or directly passing it to an aggregation or shuffle
 operation will create many references to the same object.
 If you plan to directly cache, sort, or aggregate Hadoop writable objects, you should first
 copy them using a <code>map</code> function.
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="hadoopFile(java.lang.String, java.lang.Class, java.lang.Class, java.lang.Class, int)"><!-- --></A><H3>
hadoopFile</H3>
<PRE>
public &lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>hadoopFile</B>(String&nbsp;path,
                                               Class&lt;? extends org.apache.hadoop.mapred.InputFormat&lt;K,V&gt;&gt;&nbsp;inputFormatClass,
                                               Class&lt;K&gt;&nbsp;keyClass,
                                               Class&lt;V&gt;&nbsp;valueClass,
                                               int&nbsp;minPartitions)</PRE>
<DL>
<DD>Get an RDD for a Hadoop file with an arbitrary InputFormat
 <p>
 '''Note:''' Because Hadoop's RecordReader class re-uses the same Writable object for each
 record, directly caching the returned RDD or directly passing it to an aggregation or shuffle
 operation will create many references to the same object.
 If you plan to directly cache, sort, or aggregate Hadoop writable objects, you should first
 copy them using a <code>map</code> function.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>inputFormatClass</CODE> - (undocumented)<DD><CODE>keyClass</CODE> - (undocumented)<DD><CODE>valueClass</CODE> - (undocumented)<DD><CODE>minPartitions</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="hadoopFile(java.lang.String, int, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)"><!-- --></A><H3>
hadoopFile</H3>
<PRE>
public &lt;K,V,F extends org.apache.hadoop.mapred.InputFormat&lt;K,V&gt;&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>hadoopFile</B>(String&nbsp;path,
                                                                                                   int&nbsp;minPartitions,
                                                                                                   scala.reflect.ClassTag&lt;K&gt;&nbsp;km,
                                                                                                   scala.reflect.ClassTag&lt;V&gt;&nbsp;vm,
                                                                                                   scala.reflect.ClassTag&lt;F&gt;&nbsp;fm)</PRE>
<DL>
<DD>Smarter version of hadoopFile() that uses class tags to figure out the classes of keys,
 values and the InputFormat so that users don't need to pass them directly. Instead, callers
 can just write, for example,
 <pre><code>
 val file = sparkContext.hadoopFile[LongWritable, Text, TextInputFormat](path, minPartitions)
 </code></pre>
 <p>
 '''Note:''' Because Hadoop's RecordReader class re-uses the same Writable object for each
 record, directly caching the returned RDD or directly passing it to an aggregation or shuffle
 operation will create many references to the same object.
 If you plan to directly cache, sort, or aggregate Hadoop writable objects, you should first
 copy them using a <code>map</code> function.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>minPartitions</CODE> - (undocumented)<DD><CODE>km</CODE> - (undocumented)<DD><CODE>vm</CODE> - (undocumented)<DD><CODE>fm</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="hadoopFile(java.lang.String, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)"><!-- --></A><H3>
hadoopFile</H3>
<PRE>
public &lt;K,V,F extends org.apache.hadoop.mapred.InputFormat&lt;K,V&gt;&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>hadoopFile</B>(String&nbsp;path,
                                                                                                   scala.reflect.ClassTag&lt;K&gt;&nbsp;km,
                                                                                                   scala.reflect.ClassTag&lt;V&gt;&nbsp;vm,
                                                                                                   scala.reflect.ClassTag&lt;F&gt;&nbsp;fm)</PRE>
<DL>
<DD>Smarter version of hadoopFile() that uses class tags to figure out the classes of keys,
 values and the InputFormat so that users don't need to pass them directly. Instead, callers
 can just write, for example,
 <pre><code>
 val file = sparkContext.hadoopFile[LongWritable, Text, TextInputFormat](path)
 </code></pre>
 <p>
 '''Note:''' Because Hadoop's RecordReader class re-uses the same Writable object for each
 record, directly caching the returned RDD or directly passing it to an aggregation or shuffle
 operation will create many references to the same object.
 If you plan to directly cache, sort, or aggregate Hadoop writable objects, you should first
 copy them using a <code>map</code> function.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>km</CODE> - (undocumented)<DD><CODE>vm</CODE> - (undocumented)<DD><CODE>fm</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="newAPIHadoopFile(java.lang.String, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)"><!-- --></A><H3>
newAPIHadoopFile</H3>
<PRE>
public &lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>newAPIHadoopFile</B>(String&nbsp;path,
                                                                                                            scala.reflect.ClassTag&lt;K&gt;&nbsp;km,
                                                                                                            scala.reflect.ClassTag&lt;V&gt;&nbsp;vm,
                                                                                                            scala.reflect.ClassTag&lt;F&gt;&nbsp;fm)</PRE>
<DL>
<DD>Get an RDD for a Hadoop file with an arbitrary new API InputFormat.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="newAPIHadoopFile(java.lang.String, java.lang.Class, java.lang.Class, java.lang.Class, org.apache.hadoop.conf.Configuration)"><!-- --></A><H3>
newAPIHadoopFile</H3>
<PRE>
public &lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>newAPIHadoopFile</B>(String&nbsp;path,
                                                                                                            Class&lt;F&gt;&nbsp;fClass,
                                                                                                            Class&lt;K&gt;&nbsp;kClass,
                                                                                                            Class&lt;V&gt;&nbsp;vClass,
                                                                                                            org.apache.hadoop.conf.Configuration&nbsp;conf)</PRE>
<DL>
<DD>Get an RDD for a given Hadoop file with an arbitrary new API InputFormat
 and extra configuration options to pass to the input format.
 <p>
 '''Note:''' Because Hadoop's RecordReader class re-uses the same Writable object for each
 record, directly caching the returned RDD or directly passing it to an aggregation or shuffle
 operation will create many references to the same object.
 If you plan to directly cache, sort, or aggregate Hadoop writable objects, you should first
 copy them using a <code>map</code> function.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>fClass</CODE> - (undocumented)<DD><CODE>kClass</CODE> - (undocumented)<DD><CODE>vClass</CODE> - (undocumented)<DD><CODE>conf</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="newAPIHadoopRDD(org.apache.hadoop.conf.Configuration, java.lang.Class, java.lang.Class, java.lang.Class)"><!-- --></A><H3>
newAPIHadoopRDD</H3>
<PRE>
public &lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>newAPIHadoopRDD</B>(org.apache.hadoop.conf.Configuration&nbsp;conf,
                                                                                                           Class&lt;F&gt;&nbsp;fClass,
                                                                                                           Class&lt;K&gt;&nbsp;kClass,
                                                                                                           Class&lt;V&gt;&nbsp;vClass)</PRE>
<DL>
<DD>Get an RDD for a given Hadoop file with an arbitrary new API InputFormat
 and extra configuration options to pass to the input format.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conf</CODE> - Configuration for setting up the dataset. Note: This will be put into a Broadcast.
             Therefore if you plan to reuse this conf to create multiple RDDs, you need to make
             sure you won't modify the conf. A safe approach is always creating a new conf for
             a new RDD.<DD><CODE>fClass</CODE> - Class of the InputFormat<DD><CODE>kClass</CODE> - Class of the keys<DD><CODE>vClass</CODE> - Class of the values
 <p>
 '''Note:''' Because Hadoop's RecordReader class re-uses the same Writable object for each
 record, directly caching the returned RDD or directly passing it to an aggregation or shuffle
 operation will create many references to the same object.
 If you plan to directly cache, sort, or aggregate Hadoop writable objects, you should first
 copy them using a <code>map</code> function.
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="sequenceFile(java.lang.String, java.lang.Class, java.lang.Class, int)"><!-- --></A><H3>
sequenceFile</H3>
<PRE>
public &lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>sequenceFile</B>(String&nbsp;path,
                                                 Class&lt;K&gt;&nbsp;keyClass,
                                                 Class&lt;V&gt;&nbsp;valueClass,
                                                 int&nbsp;minPartitions)</PRE>
<DL>
<DD>Get an RDD for a Hadoop SequenceFile with given key and value types.
 <p>
 '''Note:''' Because Hadoop's RecordReader class re-uses the same Writable object for each
 record, directly caching the returned RDD or directly passing it to an aggregation or shuffle
 operation will create many references to the same object.
 If you plan to directly cache, sort, or aggregate Hadoop writable objects, you should first
 copy them using a <code>map</code> function.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>keyClass</CODE> - (undocumented)<DD><CODE>valueClass</CODE> - (undocumented)<DD><CODE>minPartitions</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="sequenceFile(java.lang.String, java.lang.Class, java.lang.Class)"><!-- --></A><H3>
sequenceFile</H3>
<PRE>
public &lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>sequenceFile</B>(String&nbsp;path,
                                                 Class&lt;K&gt;&nbsp;keyClass,
                                                 Class&lt;V&gt;&nbsp;valueClass)</PRE>
<DL>
<DD>Get an RDD for a Hadoop SequenceFile with given key and value types.
 <p>
 '''Note:''' Because Hadoop's RecordReader class re-uses the same Writable object for each
 record, directly caching the returned RDD or directly passing it to an aggregation or shuffle
 operation will create many references to the same object.
 If you plan to directly cache, sort, or aggregate Hadoop writable objects, you should first
 copy them using a <code>map</code> function.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>keyClass</CODE> - (undocumented)<DD><CODE>valueClass</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="sequenceFile(java.lang.String, int, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.Function0, scala.Function0)"><!-- --></A><H3>
sequenceFile</H3>
<PRE>
public &lt;K,V&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>sequenceFile</B>(String&nbsp;path,
                                                 int&nbsp;minPartitions,
                                                 scala.reflect.ClassTag&lt;K&gt;&nbsp;km,
                                                 scala.reflect.ClassTag&lt;V&gt;&nbsp;vm,
                                                 scala.Function0&lt;org.apache.spark.WritableConverter&lt;K&gt;&gt;&nbsp;kcf,
                                                 scala.Function0&lt;org.apache.spark.WritableConverter&lt;V&gt;&gt;&nbsp;vcf)</PRE>
<DL>
<DD>Version of sequenceFile() for types implicitly convertible to Writables through a
 WritableConverter. For example, to access a SequenceFile where the keys are Text and the
 values are IntWritable, you could simply write
 <pre><code>
 sparkContext.sequenceFile[String, Int](path, ...)
 </code></pre>
 <p>
 WritableConverters are provided in a somewhat strange way (by an implicit function) to support
 both subclasses of Writable and types for which we define a converter (e.g. Int to
 IntWritable). The most natural thing would've been to have implicit objects for the
 converters, but then we couldn't have an object for every subclass of Writable (you can't
 have a parameterized singleton object). We use functions instead to create a new converter
 for the appropriate type. In addition, we pass the converter a ClassTag of its type to
 allow it to figure out the Writable class to use in the subclass case.
 <p>
 '''Note:''' Because Hadoop's RecordReader class re-uses the same Writable object for each
 record, directly caching the returned RDD or directly passing it to an aggregation or shuffle
 operation will create many references to the same object.
 If you plan to directly cache, sort, or aggregate Hadoop writable objects, you should first
 copy them using a <code>map</code> function.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>minPartitions</CODE> - (undocumented)<DD><CODE>km</CODE> - (undocumented)<DD><CODE>vm</CODE> - (undocumented)<DD><CODE>kcf</CODE> - (undocumented)<DD><CODE>vcf</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="objectFile(java.lang.String, int, scala.reflect.ClassTag)"><!-- --></A><H3>
objectFile</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt; <B>objectFile</B>(String&nbsp;path,
                             int&nbsp;minPartitions,
                             scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$4)</PRE>
<DL>
<DD>Load an RDD saved as a SequenceFile containing serialized objects, with NullWritable keys and
 BytesWritable values that contain a serialized partition. This is still an experimental
 storage format and may not be supported exactly as is in future Spark releases. It will also
 be pretty slow if you use the default serializer (Java serialization),
 though the nice thing about it is that there's very little effort required to save arbitrary
 objects.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>minPartitions</CODE> - (undocumented)<DD><CODE>evidence$4</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="union(scala.collection.Seq, scala.reflect.ClassTag)"><!-- --></A><H3>
union</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt; <B>union</B>(scala.collection.Seq&lt;<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;rdds,
                        scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$6)</PRE>
<DL>
<DD>Build the union of a list of RDDs.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="union(org.apache.spark.rdd.RDD, scala.collection.Seq, scala.reflect.ClassTag)"><!-- --></A><H3>
union</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt; <B>union</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;first,
                        scala.collection.Seq&lt;<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;rest,
                        scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$7)</PRE>
<DL>
<DD>Build the union of a list of RDDs passed as variable-length arguments.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="emptyRDD(scala.reflect.ClassTag)"><!-- --></A><H3>
emptyRDD</H3>
<PRE>
public &lt;T&gt; <any> <B>emptyRDD</B>(scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$8)</PRE>
<DL>
<DD>Get an RDD that has no partitions or elements.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="accumulator(java.lang.Object,org.apache.spark.AccumulatorParam)"><!-- --></A><A NAME="accumulator(T, org.apache.spark.AccumulatorParam)"><!-- --></A><H3>
accumulator</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../org/apache/spark/Accumulator.html" title="class in org.apache.spark">Accumulator</A>&lt;T&gt; <B>accumulator</B>(T&nbsp;initialValue,
                                      <A HREF="../../../org/apache/spark/AccumulatorParam.html" title="interface in org.apache.spark">AccumulatorParam</A>&lt;T&gt;&nbsp;param)</PRE>
<DL>
<DD>Create an <A HREF="../../../org/apache/spark/Accumulator.html" title="class in org.apache.spark"><CODE>Accumulator</CODE></A> variable of a given type, which tasks can "add"
 values to using the <code>+=</code> method. Only the driver can access the accumulator's <code>value</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - (undocumented)<DD><CODE>param</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="accumulator(java.lang.Object,java.lang.String,org.apache.spark.AccumulatorParam)"><!-- --></A><A NAME="accumulator(T, java.lang.String, org.apache.spark.AccumulatorParam)"><!-- --></A><H3>
accumulator</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../org/apache/spark/Accumulator.html" title="class in org.apache.spark">Accumulator</A>&lt;T&gt; <B>accumulator</B>(T&nbsp;initialValue,
                                      String&nbsp;name,
                                      <A HREF="../../../org/apache/spark/AccumulatorParam.html" title="interface in org.apache.spark">AccumulatorParam</A>&lt;T&gt;&nbsp;param)</PRE>
<DL>
<DD>Create an <A HREF="../../../org/apache/spark/Accumulator.html" title="class in org.apache.spark"><CODE>Accumulator</CODE></A> variable of a given type, with a name for display
 in the Spark UI. Tasks can "add" values to the accumulator using the <code>+=</code> method. Only the
 driver can access the accumulator's <code>value</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - (undocumented)<DD><CODE>name</CODE> - (undocumented)<DD><CODE>param</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="accumulable(java.lang.Object,org.apache.spark.AccumulableParam)"><!-- --></A><A NAME="accumulable(R, org.apache.spark.AccumulableParam)"><!-- --></A><H3>
accumulable</H3>
<PRE>
public &lt;R,T&gt; <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark">Accumulable</A>&lt;R,T&gt; <B>accumulable</B>(R&nbsp;initialValue,
                                          <A HREF="../../../org/apache/spark/AccumulableParam.html" title="interface in org.apache.spark">AccumulableParam</A>&lt;R,T&gt;&nbsp;param)</PRE>
<DL>
<DD>Create an <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark"><CODE>Accumulable</CODE></A> shared variable, to which tasks can add values
 with <code>+=</code>. Only the driver can access the accumuable's <code>value</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - (undocumented)<DD><CODE>param</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="accumulable(java.lang.Object,java.lang.String,org.apache.spark.AccumulableParam)"><!-- --></A><A NAME="accumulable(R, java.lang.String, org.apache.spark.AccumulableParam)"><!-- --></A><H3>
accumulable</H3>
<PRE>
public &lt;R,T&gt; <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark">Accumulable</A>&lt;R,T&gt; <B>accumulable</B>(R&nbsp;initialValue,
                                          String&nbsp;name,
                                          <A HREF="../../../org/apache/spark/AccumulableParam.html" title="interface in org.apache.spark">AccumulableParam</A>&lt;R,T&gt;&nbsp;param)</PRE>
<DL>
<DD>Create an <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark"><CODE>Accumulable</CODE></A> shared variable, with a name for display in the
 Spark UI. Tasks can add values to the accumuable using the <code>+=</code> operator. Only the driver can
 access the accumuable's <code>value</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - (undocumented)<DD><CODE>name</CODE> - (undocumented)<DD><CODE>param</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="accumulableCollection(java.lang.Object,scala.Function1,scala.reflect.ClassTag)"><!-- --></A><A NAME="accumulableCollection(R, scala.Function1, scala.reflect.ClassTag)"><!-- --></A><H3>
accumulableCollection</H3>
<PRE>
public &lt;R,T&gt; <A HREF="../../../org/apache/spark/Accumulable.html" title="class in org.apache.spark">Accumulable</A>&lt;R,T&gt; <B>accumulableCollection</B>(R&nbsp;initialValue,
                                                    scala.Function1&lt;R,scala.collection.generic.Growable&lt;T&gt;&gt;&nbsp;evidence$9,
                                                    scala.reflect.ClassTag&lt;R&gt;&nbsp;evidence$10)</PRE>
<DL>
<DD>Create an accumulator from a "mutable collection" type.
 <p>
 Growable and TraversableOnce are the standard APIs that guarantee += and ++=, implemented by
 standard mutable collections. So you can use this with mutable Map, Set, etc.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - (undocumented)<DD><CODE>evidence$9</CODE> - (undocumented)<DD><CODE>evidence$10</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="broadcast(java.lang.Object,scala.reflect.ClassTag)"><!-- --></A><A NAME="broadcast(T, scala.reflect.ClassTag)"><!-- --></A><H3>
broadcast</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../org/apache/spark/broadcast/Broadcast.html" title="class in org.apache.spark.broadcast">Broadcast</A>&lt;T&gt; <B>broadcast</B>(T&nbsp;value,
                                  scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$11)</PRE>
<DL>
<DD>Broadcast a read-only variable to the cluster, returning a
 <A HREF="../../../org/apache/spark/broadcast/Broadcast.html" title="class in org.apache.spark.broadcast"><CODE>Broadcast</CODE></A> object for reading it in distributed functions.
 The variable will be sent to each cluster only once.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - (undocumented)<DD><CODE>evidence$11</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="addFile(java.lang.String)"><!-- --></A><H3>
addFile</H3>
<PRE>
public void <B>addFile</B>(String&nbsp;path)</PRE>
<DL>
<DD>Add a file to be downloaded with this Spark job on every node.
 The <code>path</code> passed can be either a local file, a file in HDFS (or other Hadoop-supported
 filesystems), or an HTTP, HTTPS or FTP URI.  To access the file in Spark jobs,
 use <code>SparkFiles.get(fileName)</code> to find its download location.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="addFile(java.lang.String, boolean)"><!-- --></A><H3>
addFile</H3>
<PRE>
public void <B>addFile</B>(String&nbsp;path,
                    boolean&nbsp;recursive)</PRE>
<DL>
<DD>Add a file to be downloaded with this Spark job on every node.
 The <code>path</code> passed can be either a local file, a file in HDFS (or other Hadoop-supported
 filesystems), or an HTTP, HTTPS or FTP URI.  To access the file in Spark jobs,
 use <code>SparkFiles.get(fileName)</code> to find its download location.
 <p>
 A directory can be given if the recursive option is set to true. Currently directories are only
 supported for Hadoop-supported filesystems.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)<DD><CODE>recursive</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="addSparkListener(org.apache.spark.scheduler.SparkListener)"><!-- --></A><H3>
addSparkListener</H3>
<PRE>
public void <B>addSparkListener</B>(<A HREF="../../../org/apache/spark/scheduler/SparkListener.html" title="interface in org.apache.spark.scheduler">SparkListener</A>&nbsp;listener)</PRE>
<DL>
<DD>:: DeveloperApi ::
 Register a listener to receive up-calls from events that happen during execution.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="requestExecutors(int)"><!-- --></A><H3>
requestExecutors</H3>
<PRE>
public boolean <B>requestExecutors</B>(int&nbsp;numAdditionalExecutors)</PRE>
<DL>
<DD>:: DeveloperApi ::
 Request an additional number of executors from the cluster manager.
 This is currently only supported in YARN mode. Return whether the request is received.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numAdditionalExecutors</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="killExecutors(scala.collection.Seq)"><!-- --></A><H3>
killExecutors</H3>
<PRE>
public boolean <B>killExecutors</B>(scala.collection.Seq&lt;String&gt;&nbsp;executorIds)</PRE>
<DL>
<DD>:: DeveloperApi ::
 Request that the cluster manager kill the specified executors.
 This is currently only supported in YARN mode. Return whether the request is received.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>executorIds</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="killExecutor(java.lang.String)"><!-- --></A><H3>
killExecutor</H3>
<PRE>
public boolean <B>killExecutor</B>(String&nbsp;executorId)</PRE>
<DL>
<DD>:: DeveloperApi ::
 Request that cluster manager the kill the specified executor.
 This is currently only supported in Yarn mode. Return whether the request is received.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>executorId</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="version()"><!-- --></A><H3>
version</H3>
<PRE>
public String <B>version</B>()</PRE>
<DL>
<DD>The version of Spark on which this application is running.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getExecutorMemoryStatus()"><!-- --></A><H3>
getExecutorMemoryStatus</H3>
<PRE>
public scala.collection.Map&lt;String,scala.Tuple2&lt;Object,Object&gt;&gt; <B>getExecutorMemoryStatus</B>()</PRE>
<DL>
<DD>Return a map from the slave to the max memory available for caching and the remaining
 memory available for caching.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getRDDStorageInfo()"><!-- --></A><H3>
getRDDStorageInfo</H3>
<PRE>
public <A HREF="../../../org/apache/spark/storage/RDDInfo.html" title="class in org.apache.spark.storage">RDDInfo</A>[] <B>getRDDStorageInfo</B>()</PRE>
<DL>
<DD>:: DeveloperApi ::
 Return information about what RDDs are cached, if they are in mem or on disk, how much space
 they take, etc.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getPersistentRDDs()"><!-- --></A><H3>
getPersistentRDDs</H3>
<PRE>
public scala.collection.Map&lt;Object,<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;?&gt;&gt; <B>getPersistentRDDs</B>()</PRE>
<DL>
<DD>Returns an immutable map of RDDs that have marked themselves as persistent via cache() call.
 Note that this does not necessarily mean the caching or computation was successful.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getExecutorStorageStatus()"><!-- --></A><H3>
getExecutorStorageStatus</H3>
<PRE>
public <A HREF="../../../org/apache/spark/storage/StorageStatus.html" title="class in org.apache.spark.storage">StorageStatus</A>[] <B>getExecutorStorageStatus</B>()</PRE>
<DL>
<DD>:: DeveloperApi ::
 Return information about blocks stored in all of the slaves
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getAllPools()"><!-- --></A><H3>
getAllPools</H3>
<PRE>
public scala.collection.Seq&lt;org.apache.spark.scheduler.Schedulable&gt; <B>getAllPools</B>()</PRE>
<DL>
<DD>:: DeveloperApi ::
 Return pools for fair scheduler
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getPoolForName(java.lang.String)"><!-- --></A><H3>
getPoolForName</H3>
<PRE>
public scala.Option&lt;org.apache.spark.scheduler.Schedulable&gt; <B>getPoolForName</B>(String&nbsp;pool)</PRE>
<DL>
<DD>:: DeveloperApi ::
 Return the pool associated with the given name, if one exists
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pool</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getSchedulingMode()"><!-- --></A><H3>
getSchedulingMode</H3>
<PRE>
public scala.Enumeration.Value <B>getSchedulingMode</B>()</PRE>
<DL>
<DD>Return current scheduling mode
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="clearFiles()"><!-- --></A><H3>
clearFiles</H3>
<PRE>
public void <B>clearFiles</B>()</PRE>
<DL>
<DD>Clear the job's list of files added by <code>addFile</code> so that they do not get downloaded to
 any new nodes.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addJar(java.lang.String)"><!-- --></A><H3>
addJar</H3>
<PRE>
public void <B>addJar</B>(String&nbsp;path)</PRE>
<DL>
<DD>Adds a JAR dependency for all tasks to be executed on this SparkContext in the future.
 The <code>path</code> passed can be either a local file, a file in HDFS (or other Hadoop-supported
 filesystems), an HTTP, HTTPS or FTP URI, or local:/path for a file on every worker node.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="clearJars()"><!-- --></A><H3>
clearJars</H3>
<PRE>
public void <B>clearJars</B>()</PRE>
<DL>
<DD>Clear the job's list of JARs added by <code>addJar</code> so that they do not get downloaded to
 any new nodes.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="stop()"><!-- --></A><H3>
stop</H3>
<PRE>
public void <B>stop</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCallSite(java.lang.String)"><!-- --></A><H3>
setCallSite</H3>
<PRE>
public void <B>setCallSite</B>(String&nbsp;shortCallSite)</PRE>
<DL>
<DD>Set the thread-local property for overriding the call sites
 of actions and RDDs.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shortCallSite</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="clearCallSite()"><!-- --></A><H3>
clearCallSite</H3>
<PRE>
public void <B>clearCallSite</B>()</PRE>
<DL>
<DD>Clear the thread-local property for overriding the call sites
 of actions and RDDs.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="runJob(org.apache.spark.rdd.RDD, scala.Function2, scala.collection.Seq, boolean, scala.Function2, scala.reflect.ClassTag)"><!-- --></A><H3>
runJob</H3>
<PRE>
public &lt;T,U&gt; void <B>runJob</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                         scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
                         scala.collection.Seq&lt;Object&gt;&nbsp;partitions,
                         boolean&nbsp;allowLocal,
                         scala.Function2&lt;Object,U,scala.runtime.BoxedUnit&gt;&nbsp;resultHandler,
                         scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$12)</PRE>
<DL>
<DD>Run a function on a given set of partitions in an RDD and pass the results to the given
 handler function. This is the main entry point for all actions in Spark. The allowLocal
 flag specifies whether the scheduler can run the computation on the driver rather than
 shipping it out to the cluster, for short actions like first().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rdd</CODE> - (undocumented)<DD><CODE>func</CODE> - (undocumented)<DD><CODE>partitions</CODE> - (undocumented)<DD><CODE>allowLocal</CODE> - (undocumented)<DD><CODE>resultHandler</CODE> - (undocumented)<DD><CODE>evidence$12</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="runJob(org.apache.spark.rdd.RDD, scala.Function2, scala.collection.Seq, boolean, scala.reflect.ClassTag)"><!-- --></A><H3>
runJob</H3>
<PRE>
public &lt;T,U&gt; Object <B>runJob</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                           scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
                           scala.collection.Seq&lt;Object&gt;&nbsp;partitions,
                           boolean&nbsp;allowLocal,
                           scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$13)</PRE>
<DL>
<DD>Run a function on a given set of partitions in an RDD and return the results as an array. The
 allowLocal flag specifies whether the scheduler can run the computation on the driver rather
 than shipping it out to the cluster, for short actions like first().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rdd</CODE> - (undocumented)<DD><CODE>func</CODE> - (undocumented)<DD><CODE>partitions</CODE> - (undocumented)<DD><CODE>allowLocal</CODE> - (undocumented)<DD><CODE>evidence$13</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="runJob(org.apache.spark.rdd.RDD, scala.Function1, scala.collection.Seq, boolean, scala.reflect.ClassTag)"><!-- --></A><H3>
runJob</H3>
<PRE>
public &lt;T,U&gt; Object <B>runJob</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                           scala.Function1&lt;scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
                           scala.collection.Seq&lt;Object&gt;&nbsp;partitions,
                           boolean&nbsp;allowLocal,
                           scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$14)</PRE>
<DL>
<DD>Run a job on a given set of partitions of an RDD, but take a function of type
 <code>Iterator[T] =&gt; U</code> instead of <code>(TaskContext, Iterator[T]) =&gt; U</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rdd</CODE> - (undocumented)<DD><CODE>func</CODE> - (undocumented)<DD><CODE>partitions</CODE> - (undocumented)<DD><CODE>allowLocal</CODE> - (undocumented)<DD><CODE>evidence$14</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="runJob(org.apache.spark.rdd.RDD, scala.Function2, scala.reflect.ClassTag)"><!-- --></A><H3>
runJob</H3>
<PRE>
public &lt;T,U&gt; Object <B>runJob</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                           scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
                           scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$15)</PRE>
<DL>
<DD>Run a job on all partitions in an RDD and return the results in an array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rdd</CODE> - (undocumented)<DD><CODE>func</CODE> - (undocumented)<DD><CODE>evidence$15</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="runJob(org.apache.spark.rdd.RDD, scala.Function1, scala.reflect.ClassTag)"><!-- --></A><H3>
runJob</H3>
<PRE>
public &lt;T,U&gt; Object <B>runJob</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                           scala.Function1&lt;scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
                           scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$16)</PRE>
<DL>
<DD>Run a job on all partitions in an RDD and return the results in an array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rdd</CODE> - (undocumented)<DD><CODE>func</CODE> - (undocumented)<DD><CODE>evidence$16</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="runJob(org.apache.spark.rdd.RDD, scala.Function2, scala.Function2, scala.reflect.ClassTag)"><!-- --></A><H3>
runJob</H3>
<PRE>
public &lt;T,U&gt; void <B>runJob</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                         scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;processPartition,
                         scala.Function2&lt;Object,U,scala.runtime.BoxedUnit&gt;&nbsp;resultHandler,
                         scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$17)</PRE>
<DL>
<DD>Run a job on all partitions in an RDD and pass the results to a handler function.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rdd</CODE> - (undocumented)<DD><CODE>processPartition</CODE> - (undocumented)<DD><CODE>resultHandler</CODE> - (undocumented)<DD><CODE>evidence$17</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="runJob(org.apache.spark.rdd.RDD, scala.Function1, scala.Function2, scala.reflect.ClassTag)"><!-- --></A><H3>
runJob</H3>
<PRE>
public &lt;T,U&gt; void <B>runJob</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                         scala.Function1&lt;scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;processPartition,
                         scala.Function2&lt;Object,U,scala.runtime.BoxedUnit&gt;&nbsp;resultHandler,
                         scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$18)</PRE>
<DL>
<DD>Run a job on all partitions in an RDD and pass the results to a handler function.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rdd</CODE> - (undocumented)<DD><CODE>processPartition</CODE> - (undocumented)<DD><CODE>resultHandler</CODE> - (undocumented)<DD><CODE>evidence$18</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="runApproximateJob(org.apache.spark.rdd.RDD, scala.Function2, , long)"><!-- --></A><H3>
runApproximateJob</H3>
<PRE>
public &lt;T,U,R&gt; <A HREF="../../../org/apache/spark/partial/PartialResult.html" title="class in org.apache.spark.partial">PartialResult</A>&lt;R&gt; <B>runApproximateJob</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                                                  scala.Function2&lt;<A HREF="../../../org/apache/spark/TaskContext.html" title="class in org.apache.spark">TaskContext</A>,scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;func,
                                                  <any>&nbsp;evaluator,
                                                  long&nbsp;timeout)</PRE>
<DL>
<DD>:: DeveloperApi ::
 Run a job that can return approximate results.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rdd</CODE> - (undocumented)<DD><CODE>func</CODE> - (undocumented)<DD><CODE>evaluator</CODE> - (undocumented)<DD><CODE>timeout</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="submitJob(org.apache.spark.rdd.RDD, scala.Function1, scala.collection.Seq, scala.Function2, scala.Function0)"><!-- --></A><H3>
submitJob</H3>
<PRE>
public &lt;T,U,R&gt; <A HREF="../../../org/apache/spark/SimpleFutureAction.html" title="class in org.apache.spark">SimpleFutureAction</A>&lt;R&gt; <B>submitJob</B>(<A HREF="../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;rdd,
                                               scala.Function1&lt;scala.collection.Iterator&lt;T&gt;,U&gt;&nbsp;processPartition,
                                               scala.collection.Seq&lt;Object&gt;&nbsp;partitions,
                                               scala.Function2&lt;Object,U,scala.runtime.BoxedUnit&gt;&nbsp;resultHandler,
                                               scala.Function0&lt;R&gt;&nbsp;resultFunc)</PRE>
<DL>
<DD>:: Experimental ::
 Submit a job for execution and return a FutureJob holding the result.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rdd</CODE> - (undocumented)<DD><CODE>processPartition</CODE> - (undocumented)<DD><CODE>partitions</CODE> - (undocumented)<DD><CODE>resultHandler</CODE> - (undocumented)<DD><CODE>resultFunc</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="cancelJobGroup(java.lang.String)"><!-- --></A><H3>
cancelJobGroup</H3>
<PRE>
public void <B>cancelJobGroup</B>(String&nbsp;groupId)</PRE>
<DL>
<DD>Cancel active jobs for the specified group. See <CODE>org.apache.spark.SparkContext.setJobGroup</CODE>
 for more information.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>groupId</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="cancelAllJobs()"><!-- --></A><H3>
cancelAllJobs</H3>
<PRE>
public void <B>cancelAllJobs</B>()</PRE>
<DL>
<DD>Cancel all jobs that have been scheduled or are running.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCheckpointDir(java.lang.String)"><!-- --></A><H3>
setCheckpointDir</H3>
<PRE>
public void <B>setCheckpointDir</B>(String&nbsp;directory)</PRE>
<DL>
<DD>Set the directory under which RDDs are going to be checkpointed. The directory must
 be a HDFS path if running on a cluster.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>directory</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getCheckpointDir()"><!-- --></A><H3>
getCheckpointDir</H3>
<PRE>
public scala.Option&lt;String&gt; <B>getCheckpointDir</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defaultParallelism()"><!-- --></A><H3>
defaultParallelism</H3>
<PRE>
public int <B>defaultParallelism</B>()</PRE>
<DL>
<DD>Default level of parallelism to use when not given by user (e.g. parallelize and makeRDD).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defaultMinSplits()"><!-- --></A><H3>
defaultMinSplits</H3>
<PRE>
public int <B>defaultMinSplits</B>()</PRE>
<DL>
<DD>Default min number of partitions for Hadoop RDDs when not given by user
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defaultMinPartitions()"><!-- --></A><H3>
defaultMinPartitions</H3>
<PRE>
public int <B>defaultMinPartitions</B>()</PRE>
<DL>
<DD>Default min number of partitions for Hadoop RDDs when not given by user
 Notice that we use math.min so the "defaultMinPartitions" cannot be higher than 2.
 The reasons for this are discussed in https://github.com/mesos/spark/pull/718
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/apache/spark/SparkContext.DoubleAccumulatorParam$.html" title="class in org.apache.spark"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/apache/spark/SparkContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SparkContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
