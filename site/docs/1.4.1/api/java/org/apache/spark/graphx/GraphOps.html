<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_45) on Wed Jul 08 16:13:37 PDT 2015 -->
<TITLE>
GraphOps (Spark 1.4.1 JavaDoc)
</TITLE>

<META NAME="date" CONTENT="2015-07-08">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GraphOps (Spark 1.4.1 JavaDoc)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/spark/graphx/GraphLoader.html" title="class in org.apache.spark.graphx"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/spark/graphx/GraphXUtils.html" title="class in org.apache.spark.graphx"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/spark/graphx/GraphOps.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GraphOps.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.apache.spark.graphx</FONT>
<BR>
Class GraphOps&lt;VD,ED&gt;</H2>
<PRE>
Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><B>org.apache.spark.graphx.GraphOps&lt;VD,ED&gt;</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>GraphOps&lt;VD,ED&gt;</B><DT>extends Object<DT>implements scala.Serializable</DL>
</PRE>

<P>
Contains additional functionality for <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx"><CODE>Graph</CODE></A>. All operations are expressed in terms of the
 efficient GraphX API. This class is implicitly constructed for each Graph object.
 <p>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../serialized-form.html#org.apache.spark.graphx.GraphOps">Serialized Form</A></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#GraphOps(org.apache.spark.graphx.Graph, scala.reflect.ClassTag, scala.reflect.ClassTag)">GraphOps</A></B>(<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;&nbsp;graph,
         scala.reflect.ClassTag&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>&gt;&nbsp;evidence$1,
         scala.reflect.ClassTag&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;&nbsp;evidence$2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;<A HREF="../../../../org/apache/spark/graphx/Edge.html" title="class in org.apache.spark.graphx">Edge</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#collectEdges(org.apache.spark.graphx.EdgeDirection)">collectEdges</A></B>(<A HREF="../../../../org/apache/spark/graphx/EdgeDirection.html" title="class in org.apache.spark.graphx">EdgeDirection</A>&nbsp;edgeDirection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an RDD that contains for each vertex v its local edges,
 i.e., the edges that are incident on v, in the user-specified direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;long[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#collectNeighborIds(org.apache.spark.graphx.EdgeDirection)">collectNeighborIds</A></B>(<A HREF="../../../../org/apache/spark/graphx/EdgeDirection.html" title="class in org.apache.spark.graphx">EdgeDirection</A>&nbsp;edgeDirection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect the neighbor vertex ids for each vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;scala.Tuple2&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>&gt;[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#collectNeighbors(org.apache.spark.graphx.EdgeDirection)">collectNeighbors</A></B>(<A HREF="../../../../org/apache/spark/graphx/EdgeDirection.html" title="class in org.apache.spark.graphx">EdgeDirection</A>&nbsp;edgeDirection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect the neighbor vertex attributes for each vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#connectedComponents()">connectedComponents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the connected component membership of each vertex and return a graph with the vertex
 value containing the lowest vertex id in the connected component containing that vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#convertToCanonicalEdges(scala.Function2)">convertToCanonicalEdges</A></B>(scala.Function2&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;&nbsp;mergeFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convert bi-directional edges into uni-directional ones.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#degrees()">degrees</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The degree of each vertex in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;VD2,ED2&gt; <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#filter(scala.Function1, scala.Function1, scala.Function2, scala.reflect.ClassTag, scala.reflect.ClassTag)">filter</A></B>(scala.Function1&lt;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;,<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;VD2,ED2&gt;&gt;&nbsp;preprocess,
       scala.Function1&lt;<A HREF="../../../../org/apache/spark/graphx/EdgeTriplet.html" title="class in org.apache.spark.graphx">EdgeTriplet</A>&lt;VD2,ED2&gt;,Object&gt;&nbsp;epred,
       scala.Function2&lt;Object,VD2,Object&gt;&nbsp;vpred,
       scala.reflect.ClassTag&lt;VD2&gt;&nbsp;evidence$4,
       scala.reflect.ClassTag&lt;ED2&gt;&nbsp;evidence$5)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter the graph by computing some values to filter on, and applying the predicates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#inDegrees()">inDegrees</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The in-degree of each vertex in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U&gt; <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#joinVertices(org.apache.spark.rdd.RDD, scala.Function3, scala.reflect.ClassTag)">joinVertices</A></B>(<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;Object,U&gt;&gt;&nbsp;table,
             scala.Function3&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,U,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>&gt;&nbsp;mapFunc,
             scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Join the vertices with an RDD and then apply a function from the
 vertex and RDD entry to a new vertex value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#numEdges()">numEdges</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of edges in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#numVertices()">numVertices</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of vertices in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#outDegrees()">outDegrees</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The out-degree of each vertex in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#pageRank(double, double)">pageRank</A></B>(double&nbsp;tol,
         double&nbsp;resetProb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run a dynamic version of PageRank returning a graph with vertex attributes containing the
 PageRank and edge attributes containing the normalized edge weight.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#personalizedPageRank(long, double, double)">personalizedPageRank</A></B>(long&nbsp;src,
                     double&nbsp;tol,
                     double&nbsp;resetProb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run personalized PageRank for a given vertex, such that all random walks
 are started relative to the source node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#pickRandomVertex()">pickRandomVertex</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picks a random vertex from the graph and returns its ID.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;A&gt; <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#pregel(A, int, org.apache.spark.graphx.EdgeDirection, scala.Function3, scala.Function1, scala.Function2, scala.reflect.ClassTag)">pregel</A></B>(A&nbsp;initialMsg,
       int&nbsp;maxIterations,
       <A HREF="../../../../org/apache/spark/graphx/EdgeDirection.html" title="class in org.apache.spark.graphx">EdgeDirection</A>&nbsp;activeDirection,
       scala.Function3&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,A,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>&gt;&nbsp;vprog,
       scala.Function1&lt;<A HREF="../../../../org/apache/spark/graphx/EdgeTriplet.html" title="class in org.apache.spark.graphx">EdgeTriplet</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;,scala.collection.Iterator&lt;scala.Tuple2&lt;Object,A&gt;&gt;&gt;&nbsp;sendMsg,
       scala.Function2&lt;A,A,A&gt;&nbsp;mergeMsg,
       scala.reflect.ClassTag&lt;A&gt;&nbsp;evidence$6)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Execute a Pregel-like iterative vertex-parallel abstraction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#staticPageRank(int, double)">staticPageRank</A></B>(int&nbsp;numIter,
               double&nbsp;resetProb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run PageRank for a fixed number of iterations returning a graph with vertex attributes
 containing the PageRank and edge attributes the normalized edge weight.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#staticPersonalizedPageRank(long, int, double)">staticPersonalizedPageRank</A></B>(long&nbsp;src,
                           int&nbsp;numIter,
                           double&nbsp;resetProb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run Personalized PageRank for a fixed number of iterations with
 with all iterations originating at the source node
 returning a graph with vertex attributes
 containing the PageRank and edge attributes the normalized edge weight.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#stronglyConnectedComponents(int)">stronglyConnectedComponents</A></B>(int&nbsp;numIter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the strongly connected component (SCC) of each vertex and return a graph with the
 vertex value containing the lowest vertex id in the SCC containing that vertex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/graphx/GraphOps.html#triangleCount()">triangleCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the number of triangles passing through each vertex.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="GraphOps(org.apache.spark.graphx.Graph, scala.reflect.ClassTag, scala.reflect.ClassTag)"><!-- --></A><H3>
GraphOps</H3>
<PRE>
public <B>GraphOps</B>(<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;&nbsp;graph,
                scala.reflect.ClassTag&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>&gt;&nbsp;evidence$1,
                scala.reflect.ClassTag&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;&nbsp;evidence$2)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="numEdges()"><!-- --></A><H3>
numEdges</H3>
<PRE>
public long <B>numEdges</B>()</PRE>
<DL>
<DD>The number of edges in the graph.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="numVertices()"><!-- --></A><H3>
numVertices</H3>
<PRE>
public long <B>numVertices</B>()</PRE>
<DL>
<DD>The number of vertices in the graph.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="inDegrees()"><!-- --></A><H3>
inDegrees</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;Object&gt; <B>inDegrees</B>()</PRE>
<DL>
<DD>The in-degree of each vertex in the graph.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="outDegrees()"><!-- --></A><H3>
outDegrees</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;Object&gt; <B>outDegrees</B>()</PRE>
<DL>
<DD>The out-degree of each vertex in the graph.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="degrees()"><!-- --></A><H3>
degrees</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;Object&gt; <B>degrees</B>()</PRE>
<DL>
<DD>The degree of each vertex in the graph.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="collectNeighborIds(org.apache.spark.graphx.EdgeDirection)"><!-- --></A><H3>
collectNeighborIds</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;long[]&gt; <B>collectNeighborIds</B>(<A HREF="../../../../org/apache/spark/graphx/EdgeDirection.html" title="class in org.apache.spark.graphx">EdgeDirection</A>&nbsp;edgeDirection)</PRE>
<DL>
<DD>Collect the neighbor vertex ids for each vertex.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>edgeDirection</CODE> - the direction along which to collect
 neighboring vertices
 <p>
<DT><B>Returns:</B><DD>the set of neighboring ids for each vertex</DL>
</DD>
</DL>
<HR>

<A NAME="collectNeighbors(org.apache.spark.graphx.EdgeDirection)"><!-- --></A><H3>
collectNeighbors</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;scala.Tuple2&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>&gt;[]&gt; <B>collectNeighbors</B>(<A HREF="../../../../org/apache/spark/graphx/EdgeDirection.html" title="class in org.apache.spark.graphx">EdgeDirection</A>&nbsp;edgeDirection)</PRE>
<DL>
<DD>Collect the neighbor vertex attributes for each vertex.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>edgeDirection</CODE> - the direction along which to collect
 neighboring vertices
 <p>
<DT><B>Returns:</B><DD>the vertex set of neighboring vertex attributes for each vertex</DL>
</DD>
</DL>
<HR>

<A NAME="collectEdges(org.apache.spark.graphx.EdgeDirection)"><!-- --></A><H3>
collectEdges</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/VertexRDD.html" title="class in org.apache.spark.graphx">VertexRDD</A>&lt;<A HREF="../../../../org/apache/spark/graphx/Edge.html" title="class in org.apache.spark.graphx">Edge</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;[]&gt; <B>collectEdges</B>(<A HREF="../../../../org/apache/spark/graphx/EdgeDirection.html" title="class in org.apache.spark.graphx">EdgeDirection</A>&nbsp;edgeDirection)</PRE>
<DL>
<DD>Returns an RDD that contains for each vertex v its local edges,
 i.e., the edges that are incident on v, in the user-specified direction.
 Warning: note that singleton vertices, those with no edges in the given
 direction will not be part of the return value.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>edgeDirection</CODE> - the direction along which to collect
 the local edges of vertices
 <p>
<DT><B>Returns:</B><DD>the local edges for each vertex</DL>
</DD>
</DL>
<HR>

<A NAME="joinVertices(org.apache.spark.rdd.RDD, scala.Function3, scala.reflect.ClassTag)"><!-- --></A><H3>
joinVertices</H3>
<PRE>
public &lt;U&gt; <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt; <B>joinVertices</B>(<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;scala.Tuple2&lt;Object,U&gt;&gt;&nbsp;table,
                                     scala.Function3&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,U,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>&gt;&nbsp;mapFunc,
                                     scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$3)</PRE>
<DL>
<DD>Join the vertices with an RDD and then apply a function from the
 vertex and RDD entry to a new vertex value.  The input table
 should contain at most one entry for each vertex.  If no entry is
 provided the map function is skipped and the old value is used.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>table</CODE> - the table to join with the vertices in the graph.
 The table should contain at most one entry for each vertex.<DD><CODE>mapFunc</CODE> - the function used to compute the new vertex
 values.  The map function is invoked only for vertices with a
 corresponding entry in the table otherwise the old vertex value
 is used.
 <p><DD><CODE>evidence$3</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="filter(scala.Function1, scala.Function1, scala.Function2, scala.reflect.ClassTag, scala.reflect.ClassTag)"><!-- --></A><H3>
filter</H3>
<PRE>
public &lt;VD2,ED2&gt; <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt; <B>filter</B>(scala.Function1&lt;<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;,<A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;VD2,ED2&gt;&gt;&nbsp;preprocess,
                                     scala.Function1&lt;<A HREF="../../../../org/apache/spark/graphx/EdgeTriplet.html" title="class in org.apache.spark.graphx">EdgeTriplet</A>&lt;VD2,ED2&gt;,Object&gt;&nbsp;epred,
                                     scala.Function2&lt;Object,VD2,Object&gt;&nbsp;vpred,
                                     scala.reflect.ClassTag&lt;VD2&gt;&nbsp;evidence$4,
                                     scala.reflect.ClassTag&lt;ED2&gt;&nbsp;evidence$5)</PRE>
<DL>
<DD>Filter the graph by computing some values to filter on, and applying the predicates.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preprocess</CODE> - a function to compute new vertex and edge data before filtering<DD><CODE>epred</CODE> - edge pred to filter on after preprocess, see more details under
  <A HREF="../../../../org/apache/spark/graphx/Graph.html#subgraph(scala.Function1, scala.Function2)"><CODE>Graph.subgraph(scala.Function1<org.apache.spark.graphx.EdgeTriplet<VD, ED>, java.lang.Object>, scala.Function2<java.lang.Object, VD, java.lang.Object>)</CODE></A><DD><CODE>vpred</CODE> - vertex pred to filter on after prerocess, see more details under
  <A HREF="../../../../org/apache/spark/graphx/Graph.html#subgraph(scala.Function1, scala.Function2)"><CODE>Graph.subgraph(scala.Function1<org.apache.spark.graphx.EdgeTriplet<VD, ED>, java.lang.Object>, scala.Function2<java.lang.Object, VD, java.lang.Object>)</CODE></A><DD><CODE>evidence$4</CODE> - (undocumented)<DD><CODE>evidence$5</CODE> - (undocumented)
<DT><B>Returns:</B><DD>a subgraph of the orginal graph, with its data unchanged
 <p></DL>
</DD>
</DL>
<HR>

<A NAME="pickRandomVertex()"><!-- --></A><H3>
pickRandomVertex</H3>
<PRE>
public long <B>pickRandomVertex</B>()</PRE>
<DL>
<DD>Picks a random vertex from the graph and returns its ID.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="convertToCanonicalEdges(scala.Function2)"><!-- --></A><H3>
convertToCanonicalEdges</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt; <B>convertToCanonicalEdges</B>(scala.Function2&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;&nbsp;mergeFunc)</PRE>
<DL>
<DD>Convert bi-directional edges into uni-directional ones.
 Some graph algorithms (e.g., TriangleCount) assume that an input graph
 has its edges in canonical direction.
 This function rewrites the vertex ids of edges so that srcIds are bigger
 than dstIds, and merges the duplicated edges.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mergeFunc</CODE> - the user defined reduce function which should
 be commutative and associative and is used to combine the output
 of the map phase
 <p>
<DT><B>Returns:</B><DD>the resulting graph with canonical edges</DL>
</DD>
</DL>
<HR>

<A NAME="pregel(java.lang.Object,int,org.apache.spark.graphx.EdgeDirection,scala.Function3,scala.Function1,scala.Function2,scala.reflect.ClassTag)"><!-- --></A><A NAME="pregel(A, int, org.apache.spark.graphx.EdgeDirection, scala.Function3, scala.Function1, scala.Function2, scala.reflect.ClassTag)"><!-- --></A><H3>
pregel</H3>
<PRE>
public &lt;A&gt; <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt; <B>pregel</B>(A&nbsp;initialMsg,
                               int&nbsp;maxIterations,
                               <A HREF="../../../../org/apache/spark/graphx/EdgeDirection.html" title="class in org.apache.spark.graphx">EdgeDirection</A>&nbsp;activeDirection,
                               scala.Function3&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,A,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>&gt;&nbsp;vprog,
                               scala.Function1&lt;<A HREF="../../../../org/apache/spark/graphx/EdgeTriplet.html" title="class in org.apache.spark.graphx">EdgeTriplet</A>&lt;<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">VD</A>,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt;,scala.collection.Iterator&lt;scala.Tuple2&lt;Object,A&gt;&gt;&gt;&nbsp;sendMsg,
                               scala.Function2&lt;A,A,A&gt;&nbsp;mergeMsg,
                               scala.reflect.ClassTag&lt;A&gt;&nbsp;evidence$6)</PRE>
<DL>
<DD>Execute a Pregel-like iterative vertex-parallel abstraction.  The
 user-defined vertex-program <code>vprog</code> is executed in parallel on
 each vertex receiving any inbound messages and computing a new
 value for the vertex.  The <code>sendMsg</code> function is then invoked on
 all out-edges and is used to compute an optional message to the
 destination vertex. The <code>mergeMsg</code> function is a commutative
 associative function used to combine messages destined to the
 same vertex.
 <p>
 On the first iteration all vertices receive the <code>initialMsg</code> and
 on subsequent iterations if a vertex does not receive a message
 then the vertex-program is not invoked.
 <p>
 This function iterates until there are no remaining messages, or
 for <code>maxIterations</code> iterations.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialMsg</CODE> - the message each vertex will receive at the on
 the first iteration
 <p><DD><CODE>maxIterations</CODE> - the maximum number of iterations to run for
 <p><DD><CODE>activeDirection</CODE> - the direction of edges incident to a vertex that received a message in
 the previous round on which to run <code>sendMsg</code>. For example, if this is <code>EdgeDirection.Out</code>, only
 out-edges of vertices that received a message in the previous round will run.
 <p><DD><CODE>vprog</CODE> - the user-defined vertex program which runs on each
 vertex and receives the inbound message and computes a new vertex
 value.  On the first iteration the vertex program is invoked on
 all vertices and is passed the default message.  On subsequent
 iterations the vertex program is only invoked on those vertices
 that receive messages.
 <p><DD><CODE>sendMsg</CODE> - a user supplied function that is applied to out
 edges of vertices that received messages in the current
 iteration
 <p><DD><CODE>mergeMsg</CODE> - a user supplied function that takes two incoming
 messages of type A and merges them into a single message of type
 A.  ''This function must be commutative and associative and
 ideally the size of A should not increase.''
 <p><DD><CODE>evidence$6</CODE> - (undocumented)
<DT><B>Returns:</B><DD>the resulting graph at the end of the computation
 <p></DL>
</DD>
</DL>
<HR>

<A NAME="pageRank(double, double)"><!-- --></A><H3>
pageRank</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,Object&gt; <B>pageRank</B>(double&nbsp;tol,
                                     double&nbsp;resetProb)</PRE>
<DL>
<DD>Run a dynamic version of PageRank returning a graph with vertex attributes containing the
 PageRank and edge attributes containing the normalized edge weight.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tol</CODE> - (undocumented)<DD><CODE>resetProb</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)<DT><B>See Also:</B><DD><CODE>PageRank$.runUntilConvergence(org.apache.spark.graphx.Graph<VD, ED>, double, double, scala.reflect.ClassTag<VD>, scala.reflect.ClassTag<ED>)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="personalizedPageRank(long, double, double)"><!-- --></A><H3>
personalizedPageRank</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,Object&gt; <B>personalizedPageRank</B>(long&nbsp;src,
                                                 double&nbsp;tol,
                                                 double&nbsp;resetProb)</PRE>
<DL>
<DD>Run personalized PageRank for a given vertex, such that all random walks
 are started relative to the source node.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - (undocumented)<DD><CODE>tol</CODE> - (undocumented)<DD><CODE>resetProb</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)<DT><B>See Also:</B><DD><CODE>PageRank$.runUntilConvergenceWithOptions(org.apache.spark.graphx.Graph<VD, ED>, double, double, scala.Option<java.lang.Object>, scala.reflect.ClassTag<VD>, scala.reflect.ClassTag<ED>)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="staticPersonalizedPageRank(long, int, double)"><!-- --></A><H3>
staticPersonalizedPageRank</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,Object&gt; <B>staticPersonalizedPageRank</B>(long&nbsp;src,
                                                       int&nbsp;numIter,
                                                       double&nbsp;resetProb)</PRE>
<DL>
<DD>Run Personalized PageRank for a fixed number of iterations with
 with all iterations originating at the source node
 returning a graph with vertex attributes
 containing the PageRank and edge attributes the normalized edge weight.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - (undocumented)<DD><CODE>numIter</CODE> - (undocumented)<DD><CODE>resetProb</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)<DT><B>See Also:</B><DD><CODE>PageRank$.runWithOptions(org.apache.spark.graphx.Graph<VD, ED>, int, double, scala.Option<java.lang.Object>, scala.reflect.ClassTag<VD>, scala.reflect.ClassTag<ED>)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="staticPageRank(int, double)"><!-- --></A><H3>
staticPageRank</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,Object&gt; <B>staticPageRank</B>(int&nbsp;numIter,
                                           double&nbsp;resetProb)</PRE>
<DL>
<DD>Run PageRank for a fixed number of iterations returning a graph with vertex attributes
 containing the PageRank and edge attributes the normalized edge weight.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numIter</CODE> - (undocumented)<DD><CODE>resetProb</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)<DT><B>See Also:</B><DD><CODE>PageRank$.run(org.apache.spark.graphx.Graph<VD, ED>, int, double, scala.reflect.ClassTag<VD>, scala.reflect.ClassTag<ED>)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="connectedComponents()"><!-- --></A><H3>
connectedComponents</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt; <B>connectedComponents</B>()</PRE>
<DL>
<DD>Compute the connected component membership of each vertex and return a graph with the vertex
 value containing the lowest vertex id in the connected component containing that vertex.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)<DT><B>See Also:</B><DD><CODE>ConnectedComponents$.run(org.apache.spark.graphx.Graph<VD, ED>, scala.reflect.ClassTag<VD>, scala.reflect.ClassTag<ED>)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="triangleCount()"><!-- --></A><H3>
triangleCount</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt; <B>triangleCount</B>()</PRE>
<DL>
<DD>Compute the number of triangles passing through each vertex.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)<DT><B>See Also:</B><DD><CODE>TriangleCount$.run(org.apache.spark.graphx.Graph<VD, ED>, scala.reflect.ClassTag<VD>, scala.reflect.ClassTag<ED>)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="stronglyConnectedComponents(int)"><!-- --></A><H3>
stronglyConnectedComponents</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/graphx/Graph.html" title="class in org.apache.spark.graphx">Graph</A>&lt;Object,<A HREF="../../../../org/apache/spark/graphx/GraphOps.html" title="type parameter in GraphOps">ED</A>&gt; <B>stronglyConnectedComponents</B>(int&nbsp;numIter)</PRE>
<DL>
<DD>Compute the strongly connected component (SCC) of each vertex and return a graph with the
 vertex value containing the lowest vertex id in the SCC containing that vertex.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numIter</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)<DT><B>See Also:</B><DD><CODE>StronglyConnectedComponents$.run(org.apache.spark.graphx.Graph<VD, ED>, int, scala.reflect.ClassTag<VD>, scala.reflect.ClassTag<ED>)</CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/spark/graphx/GraphLoader.html" title="class in org.apache.spark.graphx"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/spark/graphx/GraphXUtils.html" title="class in org.apache.spark.graphx"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/spark/graphx/GraphOps.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GraphOps.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
