<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_45) on Wed Jul 08 16:13:37 PDT 2015 -->
<TITLE>
StreamingContext (Spark 1.4.1 JavaDoc)
</TITLE>

<META NAME="date" CONTENT="2015-07-08">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="StreamingContext (Spark 1.4.1 JavaDoc)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/spark/streaming/Seconds.html" title="class in org.apache.spark.streaming"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/spark/streaming/StreamingContextState.html" title="enum in org.apache.spark.streaming"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/spark/streaming/StreamingContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="StreamingContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.apache.spark.streaming</FONT>
<BR>
Class StreamingContext</H2>
<PRE>
Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><B>org.apache.spark.streaming.StreamingContext</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../../org/apache/spark/Logging.html" title="interface in org.apache.spark">Logging</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>StreamingContext</B><DT>extends Object<DT>implements <A HREF="../../../../org/apache/spark/Logging.html" title="interface in org.apache.spark">Logging</A></DL>
</PRE>

<P>
Main entry point for Spark Streaming functionality. It provides methods used to create
 <A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream"><CODE>DStream</CODE></A>s from various input sources. It can be either
 created by providing a Spark master URL and an appName, or from a org.apache.spark.SparkConf
 configuration (see core Spark documentation), or from an existing org.apache.spark.SparkContext.
 The associated SparkContext can be accessed using <code>context.sparkContext</code>. After
 creating and transforming DStreams, the streaming computation can be started and stopped
 using <code>context.start()</code> and <code>context.stop()</code>, respectively.
 <code>context.awaitTermination()</code> allows the current thread to wait for the termination
 of the context by <code>stop()</code> or by an exception.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#StreamingContext(org.apache.spark.SparkConf, org.apache.spark.streaming.Duration)">StreamingContext</A></B>(<A HREF="../../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;conf,
                 <A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A>&nbsp;batchDuration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a StreamingContext by providing the configuration necessary for a new SparkContext.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#StreamingContext(org.apache.spark.SparkContext, org.apache.spark.streaming.Duration)">StreamingContext</A></B>(<A HREF="../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A>&nbsp;sparkContext,
                 <A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A>&nbsp;batchDuration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a StreamingContext using an existing SparkContext.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#StreamingContext(java.lang.String)">StreamingContext</A></B>(String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recreate a StreamingContext from a checkpoint file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#StreamingContext(java.lang.String, org.apache.hadoop.conf.Configuration)">StreamingContext</A></B>(String&nbsp;path,
                 org.apache.hadoop.conf.Configuration&nbsp;hadoopConf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recreate a StreamingContext from a checkpoint file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#StreamingContext(java.lang.String, org.apache.spark.SparkContext)">StreamingContext</A></B>(String&nbsp;path,
                 <A HREF="../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A>&nbsp;sparkContext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recreate a StreamingContext from a checkpoint file using an existing SparkContext.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#StreamingContext(java.lang.String, java.lang.String, org.apache.spark.streaming.Duration, java.lang.String, scala.collection.Seq, scala.collection.Map)">StreamingContext</A></B>(String&nbsp;master,
                 String&nbsp;appName,
                 <A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A>&nbsp;batchDuration,
                 String&nbsp;sparkHome,
                 scala.collection.Seq&lt;String&gt;&nbsp;jars,
                 scala.collection.Map&lt;String,String&gt;&nbsp;environment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a StreamingContext by providing the details necessary for creating a new SparkContext.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#actorStream(akka.actor.Props, java.lang.String, org.apache.spark.storage.StorageLevel, akka.actor.SupervisorStrategy, scala.reflect.ClassTag)">actorStream</A></B>(akka.actor.Props&nbsp;props,
            String&nbsp;name,
            <A HREF="../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</A>&nbsp;storageLevel,
            akka.actor.SupervisorStrategy&nbsp;supervisorStrategy,
            scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an input stream with any arbitrary user implemented actor receiver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#addStreamingListener(org.apache.spark.streaming.scheduler.StreamingListener)">addStreamingListener</A></B>(<A HREF="../../../../org/apache/spark/streaming/scheduler/StreamingListener.html" title="interface in org.apache.spark.streaming.scheduler">StreamingListener</A>&nbsp;streamingListener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a <A HREF="../../../../org/apache/spark/streaming/scheduler/StreamingListener.html" title="interface in org.apache.spark.streaming.scheduler"><CODE>StreamingListener</CODE></A> object for
 receiving system events related to streaming.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#awaitTermination()">awaitTermination</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for the execution to stop.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#awaitTermination(long)">awaitTermination</A></B>(long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of 1.3.0, replaced by <code>awaitTerminationOrTimeout(Long)</code>.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#awaitTerminationOrTimeout(long)">awaitTerminationOrTimeout</A></B>(long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for the execution to stop.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;byte[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#binaryRecordsStream(java.lang.String, int)">binaryRecordsStream</A></B>(String&nbsp;directory,
                    int&nbsp;recordLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Experimental ::</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#checkpoint(java.lang.String)">checkpoint</A></B>(String&nbsp;directory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the context to periodically checkpoint the DStream operations for driver
 fault-tolerance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#checkpointDir()">checkpointDir</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#checkpointDuration()">checkpointDuration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#conf()">conf</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/SparkEnv.html" title="class in org.apache.spark">SparkEnv</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#env()">env</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; 
<BR>
<A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#fileStream(java.lang.String, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">fileStream</A></B>(String&nbsp;directory,
           scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$6,
           scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$7,
           scala.reflect.ClassTag&lt;F&gt;&nbsp;evidence$8)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a input stream that monitors a Hadoop-compatible filesystem
 for new files and reads them using the given key-value types and input format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; 
<BR>
<A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#fileStream(java.lang.String, scala.Function1, boolean, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">fileStream</A></B>(String&nbsp;directory,
           scala.Function1&lt;org.apache.hadoop.fs.Path,Object&gt;&nbsp;filter,
           boolean&nbsp;newFilesOnly,
           scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$9,
           scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$10,
           scala.reflect.ClassTag&lt;F&gt;&nbsp;evidence$11)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a input stream that monitors a Hadoop-compatible filesystem
 for new files and reads them using the given key-value types and input format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; 
<BR>
<A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#fileStream(java.lang.String, scala.Function1, boolean, org.apache.hadoop.conf.Configuration, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">fileStream</A></B>(String&nbsp;directory,
           scala.Function1&lt;org.apache.hadoop.fs.Path,Object&gt;&nbsp;filter,
           boolean&nbsp;newFilesOnly,
           org.apache.hadoop.conf.Configuration&nbsp;conf,
           scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$12,
           scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$13,
           scala.reflect.ClassTag&lt;F&gt;&nbsp;evidence$14)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a input stream that monitors a Hadoop-compatible filesystem
 for new files and reads them using the given key-value types and input format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;scala.Option&lt;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#getActive()">getActive</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Experimental ::</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#getActiveOrCreate(scala.Function0)">getActiveOrCreate</A></B>(scala.Function0&lt;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A>&gt;&nbsp;creatingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Experimental ::</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#getActiveOrCreate(java.lang.String, scala.Function0, org.apache.hadoop.conf.Configuration, boolean)">getActiveOrCreate</A></B>(String&nbsp;checkpointPath,
                  scala.Function0&lt;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A>&gt;&nbsp;creatingFunc,
                  org.apache.hadoop.conf.Configuration&nbsp;hadoopConf,
                  boolean&nbsp;createOnError)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: Experimental ::</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#getOrCreate(java.lang.String, scala.Function0, org.apache.hadoop.conf.Configuration, boolean)">getOrCreate</A></B>(String&nbsp;checkpointPath,
            scala.Function0&lt;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A>&gt;&nbsp;creatingFunc,
            org.apache.hadoop.conf.Configuration&nbsp;hadoopConf,
            boolean&nbsp;createOnError)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Either recreate a StreamingContext from checkpoint data or create a new StreamingContext.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/streaming/StreamingContextState.html" title="enum in org.apache.spark.streaming">StreamingContextState</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#getState()">getState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: DeveloperApi ::</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.apache.spark.streaming.DStreamGraph</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#graph()">graph</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#isCheckpointPresent()">isCheckpointPresent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;scala.Option&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#jarOfClass(java.lang.Class)">jarOfClass</A></B>(Class&lt;?&gt;&nbsp;cls)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the JAR from which a given class was loaded, to make it easy for users to pass
 their JARs to StreamingContext.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#networkStream(org.apache.spark.streaming.receiver.Receiver, scala.reflect.ClassTag)">networkStream</A></B>(<A HREF="../../../../org/apache/spark/streaming/receiver/Receiver.html" title="class in org.apache.spark.streaming.receiver">Receiver</A>&lt;T&gt;&nbsp;receiver,
              scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of 1.0.0", replaced by <code>receiverStream</code>.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.apache.spark.streaming.ui.StreamingJobProgressListener</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#progressListener()">progressListener</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#queueStream(scala.collection.mutable.Queue, boolean, scala.reflect.ClassTag)">queueStream</A></B>(scala.collection.mutable.Queue&lt;<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;queue,
            boolean&nbsp;oneAtATime,
            scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$15)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an input stream from a queue of RDDs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#queueStream(scala.collection.mutable.Queue, boolean, org.apache.spark.rdd.RDD, scala.reflect.ClassTag)">queueStream</A></B>(scala.collection.mutable.Queue&lt;<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;queue,
            boolean&nbsp;oneAtATime,
            <A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;defaultRDD,
            scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$16)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an input stream from a queue of RDDs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#rawSocketStream(java.lang.String, int, org.apache.spark.storage.StorageLevel, scala.reflect.ClassTag)">rawSocketStream</A></B>(String&nbsp;hostname,
                int&nbsp;port,
                <A HREF="../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</A>&nbsp;storageLevel,
                scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$5)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a input stream from network source hostname:port, where data is received
 as serialized blocks (serialized using the Spark's serializer) that can be directly
 pushed into the block manager without deserializing them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#receiverStream(org.apache.spark.streaming.receiver.Receiver, scala.reflect.ClassTag)">receiverStream</A></B>(<A HREF="../../../../org/apache/spark/streaming/receiver/Receiver.html" title="class in org.apache.spark.streaming.receiver">Receiver</A>&lt;T&gt;&nbsp;receiver,
               scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an input stream with any arbitrary user implemented receiver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#remember(org.apache.spark.streaming.Duration)">remember</A></B>(<A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A>&nbsp;duration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set each DStreams in this context to remember RDDs it generated in the last given duration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#sc()">sc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.apache.spark.streaming.scheduler.JobScheduler</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#scheduler()">scheduler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#socketStream(java.lang.String, int, scala.Function1, org.apache.spark.storage.StorageLevel, scala.reflect.ClassTag)">socketStream</A></B>(String&nbsp;hostname,
             int&nbsp;port,
             scala.Function1&lt;java.io.InputStream,scala.collection.Iterator&lt;T&gt;&gt;&nbsp;converter,
             <A HREF="../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</A>&nbsp;storageLevel,
             scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a input stream from TCP source hostname:port.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#socketTextStream(java.lang.String, int, org.apache.spark.storage.StorageLevel)">socketTextStream</A></B>(String&nbsp;hostname,
                 int&nbsp;port,
                 <A HREF="../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</A>&nbsp;storageLevel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a input stream from TCP source hostname:port.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#sparkContext()">sparkContext</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the associated Spark context</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#start()">start</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start the execution of the streams.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#stop(boolean)">stop</A></B>(boolean&nbsp;stopSparkContext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stop the execution of the streams immediately (does not wait for all received data
 to be processed).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#stop(boolean, boolean)">stop</A></B>(boolean&nbsp;stopSparkContext,
     boolean&nbsp;stopGracefully)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stop the execution of the streams, with option of ensuring all received data
 has been processed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#textFileStream(java.lang.String)">textFileStream</A></B>(String&nbsp;directory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a input stream that monitors a Hadoop-compatible filesystem
 for new files and reads them as text files (using key as LongWritable, value
 as Text and input format as TextInputFormat).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K,V&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/PairDStreamFunctions.html" title="class in org.apache.spark.streaming.dstream">PairDStreamFunctions</A>&lt;K,V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#toPairDStreamFunctions(org.apache.spark.streaming.dstream.DStream, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.math.Ordering)">toPairDStreamFunctions</A></B>(<A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;stream,
                       scala.reflect.ClassTag&lt;K&gt;&nbsp;kt,
                       scala.reflect.ClassTag&lt;V&gt;&nbsp;vt,
                       scala.math.Ordering&lt;K&gt;&nbsp;ord)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of 1.3.0, replaced by implicit functions in the DStream companion object.
             This is kept here only for backward compatibility.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#transform(scala.collection.Seq, scala.Function2, scala.reflect.ClassTag)">transform</A></B>(scala.collection.Seq&lt;<A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;?&gt;&gt;&nbsp;dstreams,
          scala.Function2&lt;scala.collection.Seq&lt;<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;?&gt;&gt;,<A HREF="../../../../org/apache/spark/streaming/Time.html" title="class in org.apache.spark.streaming">Time</A>,<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;transformFunc,
          scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$18)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new DStream in which each RDD is generated by applying a function on RDDs of
 the DStreams.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;scala.Option&lt;org.apache.spark.streaming.ui.StreamingTab&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#uiTab()">uiTab</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#union(scala.collection.Seq, scala.reflect.ClassTag)">union</A></B>(scala.collection.Seq&lt;<A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;T&gt;&gt;&nbsp;streams,
      scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$17)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a unified DStream from multiple DStreams of the same type and same slide duration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;org.apache.spark.streaming.ContextWaiter</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/spark/streaming/StreamingContext.html#waiter()">waiter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.apache.spark.Logging"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface org.apache.spark.<A HREF="../../../../org/apache/spark/Logging.html" title="interface in org.apache.spark">Logging</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../org/apache/spark/Logging.html#initializeIfNecessary()">initializeIfNecessary</A>, <A HREF="../../../../org/apache/spark/Logging.html#initializeLogging()">initializeLogging</A>, <A HREF="../../../../org/apache/spark/Logging.html#isTraceEnabled()">isTraceEnabled</A>, <A HREF="../../../../org/apache/spark/Logging.html#log_()">log_</A>, <A HREF="../../../../org/apache/spark/Logging.html#log()">log</A>, <A HREF="../../../../org/apache/spark/Logging.html#logDebug(scala.Function0)">logDebug</A>, <A HREF="../../../../org/apache/spark/Logging.html#logDebug(scala.Function0, java.lang.Throwable)">logDebug</A>, <A HREF="../../../../org/apache/spark/Logging.html#logError(scala.Function0)">logError</A>, <A HREF="../../../../org/apache/spark/Logging.html#logError(scala.Function0, java.lang.Throwable)">logError</A>, <A HREF="../../../../org/apache/spark/Logging.html#logInfo(scala.Function0)">logInfo</A>, <A HREF="../../../../org/apache/spark/Logging.html#logInfo(scala.Function0, java.lang.Throwable)">logInfo</A>, <A HREF="../../../../org/apache/spark/Logging.html#logName()">logName</A>, <A HREF="../../../../org/apache/spark/Logging.html#logTrace(scala.Function0)">logTrace</A>, <A HREF="../../../../org/apache/spark/Logging.html#logTrace(scala.Function0, java.lang.Throwable)">logTrace</A>, <A HREF="../../../../org/apache/spark/Logging.html#logWarning(scala.Function0)">logWarning</A>, <A HREF="../../../../org/apache/spark/Logging.html#logWarning(scala.Function0, java.lang.Throwable)">logWarning</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="StreamingContext(org.apache.spark.SparkContext, org.apache.spark.streaming.Duration)"><!-- --></A><H3>
StreamingContext</H3>
<PRE>
public <B>StreamingContext</B>(<A HREF="../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A>&nbsp;sparkContext,
                        <A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A>&nbsp;batchDuration)</PRE>
<DL>
<DD>Create a StreamingContext using an existing SparkContext.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>sparkContext</CODE> - existing SparkContext<DD><CODE>batchDuration</CODE> - the time interval at which streaming data will be divided into batches</DL>
</DL>
<HR>

<A NAME="StreamingContext(org.apache.spark.SparkConf, org.apache.spark.streaming.Duration)"><!-- --></A><H3>
StreamingContext</H3>
<PRE>
public <B>StreamingContext</B>(<A HREF="../../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A>&nbsp;conf,
                        <A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A>&nbsp;batchDuration)</PRE>
<DL>
<DD>Create a StreamingContext by providing the configuration necessary for a new SparkContext.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>conf</CODE> - a org.apache.spark.SparkConf object specifying Spark parameters<DD><CODE>batchDuration</CODE> - the time interval at which streaming data will be divided into batches</DL>
</DL>
<HR>

<A NAME="StreamingContext(java.lang.String, java.lang.String, org.apache.spark.streaming.Duration, java.lang.String, scala.collection.Seq, scala.collection.Map)"><!-- --></A><H3>
StreamingContext</H3>
<PRE>
public <B>StreamingContext</B>(String&nbsp;master,
                        String&nbsp;appName,
                        <A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A>&nbsp;batchDuration,
                        String&nbsp;sparkHome,
                        scala.collection.Seq&lt;String&gt;&nbsp;jars,
                        scala.collection.Map&lt;String,String&gt;&nbsp;environment)</PRE>
<DL>
<DD>Create a StreamingContext by providing the details necessary for creating a new SparkContext.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>master</CODE> - cluster URL to connect to (e.g. mesos://host:port, spark://host:port, local[4]).<DD><CODE>appName</CODE> - a name for your job, to display on the cluster web UI<DD><CODE>batchDuration</CODE> - the time interval at which streaming data will be divided into batches<DD><CODE>sparkHome</CODE> - (undocumented)<DD><CODE>jars</CODE> - (undocumented)<DD><CODE>environment</CODE> - (undocumented)</DL>
</DL>
<HR>

<A NAME="StreamingContext(java.lang.String, org.apache.hadoop.conf.Configuration)"><!-- --></A><H3>
StreamingContext</H3>
<PRE>
public <B>StreamingContext</B>(String&nbsp;path,
                        org.apache.hadoop.conf.Configuration&nbsp;hadoopConf)</PRE>
<DL>
<DD>Recreate a StreamingContext from a checkpoint file.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - Path to the directory that was specified as the checkpoint directory<DD><CODE>hadoopConf</CODE> - Optional, configuration object if necessary for reading from
                   HDFS compatible filesystems</DL>
</DL>
<HR>

<A NAME="StreamingContext(java.lang.String)"><!-- --></A><H3>
StreamingContext</H3>
<PRE>
public <B>StreamingContext</B>(String&nbsp;path)</PRE>
<DL>
<DD>Recreate a StreamingContext from a checkpoint file.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - Path to the directory that was specified as the checkpoint directory</DL>
</DL>
<HR>

<A NAME="StreamingContext(java.lang.String, org.apache.spark.SparkContext)"><!-- --></A><H3>
StreamingContext</H3>
<PRE>
public <B>StreamingContext</B>(String&nbsp;path,
                        <A HREF="../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A>&nbsp;sparkContext)</PRE>
<DL>
<DD>Recreate a StreamingContext from a checkpoint file using an existing SparkContext.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - Path to the directory that was specified as the checkpoint directory<DD><CODE>sparkContext</CODE> - Existing SparkContext</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getActive()"><!-- --></A><H3>
getActive</H3>
<PRE>
public static scala.Option&lt;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A>&gt; <B>getActive</B>()</PRE>
<DL>
<DD>:: Experimental ::
 <p>
 Get the currently active context, if there is one. Active means started but not stopped.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="toPairDStreamFunctions(org.apache.spark.streaming.dstream.DStream, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.math.Ordering)"><!-- --></A><H3>
toPairDStreamFunctions</H3>
<PRE>
public static &lt;K,V&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/PairDStreamFunctions.html" title="class in org.apache.spark.streaming.dstream">PairDStreamFunctions</A>&lt;K,V&gt; <B>toPairDStreamFunctions</B>(<A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;stream,
                                                                     scala.reflect.ClassTag&lt;K&gt;&nbsp;kt,
                                                                     scala.reflect.ClassTag&lt;V&gt;&nbsp;vt,
                                                                     scala.math.Ordering&lt;K&gt;&nbsp;ord)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of 1.3.0, replaced by implicit functions in the DStream companion object.
             This is kept here only for backward compatibility.</I>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - (undocumented)<DD><CODE>kt</CODE> - (undocumented)<DD><CODE>vt</CODE> - (undocumented)<DD><CODE>ord</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getActiveOrCreate(scala.Function0)"><!-- --></A><H3>
getActiveOrCreate</H3>
<PRE>
public static <A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A> <B>getActiveOrCreate</B>(scala.Function0&lt;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A>&gt;&nbsp;creatingFunc)</PRE>
<DL>
<DD>:: Experimental ::
 <p>
 Either return the "active" StreamingContext (that is, started but not stopped), or create a
 new StreamingContext that is
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>creatingFunc</CODE> - Function to create a new StreamingContext
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getActiveOrCreate(java.lang.String, scala.Function0, org.apache.hadoop.conf.Configuration, boolean)"><!-- --></A><H3>
getActiveOrCreate</H3>
<PRE>
public static <A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A> <B>getActiveOrCreate</B>(String&nbsp;checkpointPath,
                                                 scala.Function0&lt;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A>&gt;&nbsp;creatingFunc,
                                                 org.apache.hadoop.conf.Configuration&nbsp;hadoopConf,
                                                 boolean&nbsp;createOnError)</PRE>
<DL>
<DD>:: Experimental ::
 <p>
 Either get the currently active StreamingContext (that is, started but not stopped),
 OR recreate a StreamingContext from checkpoint data in the given path. If checkpoint data
 does not exist in the provided, then create a new StreamingContext by calling the provided
 <code>creatingFunc</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>checkpointPath</CODE> - Checkpoint directory used in an earlier StreamingContext program<DD><CODE>creatingFunc</CODE> - Function to create a new StreamingContext<DD><CODE>hadoopConf</CODE> - Optional Hadoop configuration if necessary for reading from the
                       file system<DD><CODE>createOnError</CODE> - Optional, whether to create a new StreamingContext if there is an
                       error in reading checkpoint data. By default, an exception will be
                       thrown on error.
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getOrCreate(java.lang.String, scala.Function0, org.apache.hadoop.conf.Configuration, boolean)"><!-- --></A><H3>
getOrCreate</H3>
<PRE>
public static <A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A> <B>getOrCreate</B>(String&nbsp;checkpointPath,
                                           scala.Function0&lt;<A HREF="../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</A>&gt;&nbsp;creatingFunc,
                                           org.apache.hadoop.conf.Configuration&nbsp;hadoopConf,
                                           boolean&nbsp;createOnError)</PRE>
<DL>
<DD>Either recreate a StreamingContext from checkpoint data or create a new StreamingContext.
 If checkpoint data exists in the provided <code>checkpointPath</code>, then StreamingContext will be
 recreated from the checkpoint data. If the data does not exist, then the StreamingContext
 will be created by called the provided <code>creatingFunc</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>checkpointPath</CODE> - Checkpoint directory used in an earlier StreamingContext program<DD><CODE>creatingFunc</CODE> - Function to create a new StreamingContext<DD><CODE>hadoopConf</CODE> - Optional Hadoop configuration if necessary for reading from the
                       file system<DD><CODE>createOnError</CODE> - Optional, whether to create a new StreamingContext if there is an
                       error in reading checkpoint data. By default, an exception will be
                       thrown on error.
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="jarOfClass(java.lang.Class)"><!-- --></A><H3>
jarOfClass</H3>
<PRE>
public static scala.Option&lt;String&gt; <B>jarOfClass</B>(Class&lt;?&gt;&nbsp;cls)</PRE>
<DL>
<DD>Find the JAR from which a given class was loaded, to make it easy for users to pass
 their JARs to StreamingContext.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cls</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="isCheckpointPresent()"><!-- --></A><H3>
isCheckpointPresent</H3>
<PRE>
public boolean <B>isCheckpointPresent</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sc()"><!-- --></A><H3>
sc</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A> <B>sc</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="conf()"><!-- --></A><H3>
conf</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/SparkConf.html" title="class in org.apache.spark">SparkConf</A> <B>conf</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="env()"><!-- --></A><H3>
env</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/SparkEnv.html" title="class in org.apache.spark">SparkEnv</A> <B>env</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="graph()"><!-- --></A><H3>
graph</H3>
<PRE>
public org.apache.spark.streaming.DStreamGraph <B>graph</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkpointDir()"><!-- --></A><H3>
checkpointDir</H3>
<PRE>
public String <B>checkpointDir</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkpointDuration()"><!-- --></A><H3>
checkpointDuration</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A> <B>checkpointDuration</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scheduler()"><!-- --></A><H3>
scheduler</H3>
<PRE>
public org.apache.spark.streaming.scheduler.JobScheduler <B>scheduler</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="waiter()"><!-- --></A><H3>
waiter</H3>
<PRE>
public org.apache.spark.streaming.ContextWaiter <B>waiter</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="progressListener()"><!-- --></A><H3>
progressListener</H3>
<PRE>
public org.apache.spark.streaming.ui.StreamingJobProgressListener <B>progressListener</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="uiTab()"><!-- --></A><H3>
uiTab</H3>
<PRE>
public scala.Option&lt;org.apache.spark.streaming.ui.StreamingTab&gt; <B>uiTab</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sparkContext()"><!-- --></A><H3>
sparkContext</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</A> <B>sparkContext</B>()</PRE>
<DL>
<DD>Return the associated Spark context
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="remember(org.apache.spark.streaming.Duration)"><!-- --></A><H3>
remember</H3>
<PRE>
public void <B>remember</B>(<A HREF="../../../../org/apache/spark/streaming/Duration.html" title="class in org.apache.spark.streaming">Duration</A>&nbsp;duration)</PRE>
<DL>
<DD>Set each DStreams in this context to remember RDDs it generated in the last given duration.
 DStreams remember RDDs only for a limited duration of time and releases them for garbage
 collection. This method allows the developer to specify how long to remember the RDDs (
 if the developer wishes to query old data outside the DStream computation).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>duration</CODE> - Minimum duration that each DStream should remember its RDDs</DL>
</DD>
</DL>
<HR>

<A NAME="checkpoint(java.lang.String)"><!-- --></A><H3>
checkpoint</H3>
<PRE>
public void <B>checkpoint</B>(String&nbsp;directory)</PRE>
<DL>
<DD>Set the context to periodically checkpoint the DStream operations for driver
 fault-tolerance.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>directory</CODE> - HDFS-compatible directory where the checkpoint data will be reliably stored.
                  Note that this must be a fault-tolerant file system like HDFS for</DL>
</DD>
</DL>
<HR>

<A NAME="networkStream(org.apache.spark.streaming.receiver.Receiver, scala.reflect.ClassTag)"><!-- --></A><H3>
networkStream</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt; <B>networkStream</B>(<A HREF="../../../../org/apache/spark/streaming/receiver/Receiver.html" title="class in org.apache.spark.streaming.receiver">Receiver</A>&lt;T&gt;&nbsp;receiver,
                                                 scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$1)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of 1.0.0", replaced by <code>receiverStream</code>.</I>
<P>
<DD>Create an input stream with any arbitrary user implemented receiver.
 Find more details at: http://spark.apache.org/docs/latest/streaming-custom-receivers.html
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>receiver</CODE> - Custom implementation of Receiver
 <p><DD><CODE>evidence$1</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="receiverStream(org.apache.spark.streaming.receiver.Receiver, scala.reflect.ClassTag)"><!-- --></A><H3>
receiverStream</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt; <B>receiverStream</B>(<A HREF="../../../../org/apache/spark/streaming/receiver/Receiver.html" title="class in org.apache.spark.streaming.receiver">Receiver</A>&lt;T&gt;&nbsp;receiver,
                                                  scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$2)</PRE>
<DL>
<DD>Create an input stream with any arbitrary user implemented receiver.
 Find more details at: http://spark.apache.org/docs/latest/streaming-custom-receivers.html
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>receiver</CODE> - Custom implementation of Receiver<DD><CODE>evidence$2</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="actorStream(akka.actor.Props, java.lang.String, org.apache.spark.storage.StorageLevel, akka.actor.SupervisorStrategy, scala.reflect.ClassTag)"><!-- --></A><H3>
actorStream</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt; <B>actorStream</B>(akka.actor.Props&nbsp;props,
                                               String&nbsp;name,
                                               <A HREF="../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</A>&nbsp;storageLevel,
                                               akka.actor.SupervisorStrategy&nbsp;supervisorStrategy,
                                               scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$3)</PRE>
<DL>
<DD>Create an input stream with any arbitrary user implemented actor receiver.
 Find more details at: http://spark.apache.org/docs/latest/streaming-custom-receivers.html
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>props</CODE> - Props object defining creation of the actor<DD><CODE>name</CODE> - Name of the actor<DD><CODE>storageLevel</CODE> - RDD storage level (default: StorageLevel.MEMORY_AND_DISK_SER_2)
 <p><DD><CODE>supervisorStrategy</CODE> - (undocumented)<DD><CODE>evidence$3</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="socketTextStream(java.lang.String, int, org.apache.spark.storage.StorageLevel)"><!-- --></A><H3>
socketTextStream</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;String&gt; <B>socketTextStream</B>(String&nbsp;hostname,
                                                     int&nbsp;port,
                                                     <A HREF="../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</A>&nbsp;storageLevel)</PRE>
<DL>
<DD>Create a input stream from TCP source hostname:port. Data is received using
 a TCP socket and the receive bytes is interpreted as UTF8 encoded <code>\n</code> delimited
 lines.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hostname</CODE> - Hostname to connect to for receiving data<DD><CODE>port</CODE> - Port to connect to for receiving data<DD><CODE>storageLevel</CODE> - Storage level to use for storing the received objects
                      (default: StorageLevel.MEMORY_AND_DISK_SER_2)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="socketStream(java.lang.String, int, scala.Function1, org.apache.spark.storage.StorageLevel, scala.reflect.ClassTag)"><!-- --></A><H3>
socketStream</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt; <B>socketStream</B>(String&nbsp;hostname,
                                                int&nbsp;port,
                                                scala.Function1&lt;java.io.InputStream,scala.collection.Iterator&lt;T&gt;&gt;&nbsp;converter,
                                                <A HREF="../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</A>&nbsp;storageLevel,
                                                scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$4)</PRE>
<DL>
<DD>Create a input stream from TCP source hostname:port. Data is received using
 a TCP socket and the receive bytes it interepreted as object using the given
 converter.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hostname</CODE> - Hostname to connect to for receiving data<DD><CODE>port</CODE> - Port to connect to for receiving data<DD><CODE>converter</CODE> - Function to convert the byte stream to objects<DD><CODE>storageLevel</CODE> - Storage level to use for storing the received objects<DD><CODE>evidence$4</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="rawSocketStream(java.lang.String, int, org.apache.spark.storage.StorageLevel, scala.reflect.ClassTag)"><!-- --></A><H3>
rawSocketStream</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</A>&lt;T&gt; <B>rawSocketStream</B>(String&nbsp;hostname,
                                                   int&nbsp;port,
                                                   <A HREF="../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</A>&nbsp;storageLevel,
                                                   scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$5)</PRE>
<DL>
<DD>Create a input stream from network source hostname:port, where data is received
 as serialized blocks (serialized using the Spark's serializer) that can be directly
 pushed into the block manager without deserializing them. This is the most efficient
 way to receive data.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hostname</CODE> - Hostname to connect to for receiving data<DD><CODE>port</CODE> - Port to connect to for receiving data<DD><CODE>storageLevel</CODE> - Storage level to use for storing the received objects
                      (default: StorageLevel.MEMORY_AND_DISK_SER_2)<DD><CODE>evidence$5</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="fileStream(java.lang.String, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)"><!-- --></A><H3>
fileStream</H3>
<PRE>
public &lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>fileStream</B>(String&nbsp;directory,
                                                                                                               scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$6,
                                                                                                               scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$7,
                                                                                                               scala.reflect.ClassTag&lt;F&gt;&nbsp;evidence$8)</PRE>
<DL>
<DD>Create a input stream that monitors a Hadoop-compatible filesystem
 for new files and reads them using the given key-value types and input format.
 Files must be written to the monitored directory by "moving" them from another
 location within the same file system. File names starting with . are ignored.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>directory</CODE> - HDFS directory to monitor for new file<DD><CODE>evidence$6</CODE> - (undocumented)<DD><CODE>evidence$7</CODE> - (undocumented)<DD><CODE>evidence$8</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="fileStream(java.lang.String, scala.Function1, boolean, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)"><!-- --></A><H3>
fileStream</H3>
<PRE>
public &lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>fileStream</B>(String&nbsp;directory,
                                                                                                               scala.Function1&lt;org.apache.hadoop.fs.Path,Object&gt;&nbsp;filter,
                                                                                                               boolean&nbsp;newFilesOnly,
                                                                                                               scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$9,
                                                                                                               scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$10,
                                                                                                               scala.reflect.ClassTag&lt;F&gt;&nbsp;evidence$11)</PRE>
<DL>
<DD>Create a input stream that monitors a Hadoop-compatible filesystem
 for new files and reads them using the given key-value types and input format.
 Files must be written to the monitored directory by "moving" them from another
 location within the same file system.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>directory</CODE> - HDFS directory to monitor for new file<DD><CODE>filter</CODE> - Function to filter paths to process<DD><CODE>newFilesOnly</CODE> - Should process only new files and ignore existing files in the directory<DD><CODE>evidence$9</CODE> - (undocumented)<DD><CODE>evidence$10</CODE> - (undocumented)<DD><CODE>evidence$11</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="fileStream(java.lang.String, scala.Function1, boolean, org.apache.hadoop.conf.Configuration, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)"><!-- --></A><H3>
fileStream</H3>
<PRE>
public &lt;K,V,F extends org.apache.hadoop.mapreduce.InputFormat&lt;K,V&gt;&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;scala.Tuple2&lt;K,V&gt;&gt; <B>fileStream</B>(String&nbsp;directory,
                                                                                                               scala.Function1&lt;org.apache.hadoop.fs.Path,Object&gt;&nbsp;filter,
                                                                                                               boolean&nbsp;newFilesOnly,
                                                                                                               org.apache.hadoop.conf.Configuration&nbsp;conf,
                                                                                                               scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$12,
                                                                                                               scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$13,
                                                                                                               scala.reflect.ClassTag&lt;F&gt;&nbsp;evidence$14)</PRE>
<DL>
<DD>Create a input stream that monitors a Hadoop-compatible filesystem
 for new files and reads them using the given key-value types and input format.
 Files must be written to the monitored directory by "moving" them from another
 location within the same file system. File names starting with . are ignored.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>directory</CODE> - HDFS directory to monitor for new file<DD><CODE>filter</CODE> - Function to filter paths to process<DD><CODE>newFilesOnly</CODE> - Should process only new files and ignore existing files in the directory<DD><CODE>conf</CODE> - Hadoop configuration<DD><CODE>evidence$12</CODE> - (undocumented)<DD><CODE>evidence$13</CODE> - (undocumented)<DD><CODE>evidence$14</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="textFileStream(java.lang.String)"><!-- --></A><H3>
textFileStream</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;String&gt; <B>textFileStream</B>(String&nbsp;directory)</PRE>
<DL>
<DD>Create a input stream that monitors a Hadoop-compatible filesystem
 for new files and reads them as text files (using key as LongWritable, value
 as Text and input format as TextInputFormat). Files must be written to the
 monitored directory by "moving" them from another location within the same
 file system. File names starting with . are ignored.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>directory</CODE> - HDFS directory to monitor for new file
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="binaryRecordsStream(java.lang.String, int)"><!-- --></A><H3>
binaryRecordsStream</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;byte[]&gt; <B>binaryRecordsStream</B>(String&nbsp;directory,
                                           int&nbsp;recordLength)</PRE>
<DL>
<DD>:: Experimental ::
 <p>
 Create an input stream that monitors a Hadoop-compatible filesystem
 for new files and reads them as flat binary files, assuming a fixed length per record,
 generating one byte array per record. Files must be written to the monitored directory
 by "moving" them from another location within the same file system. File names
 starting with . are ignored.
 <p>
 '''Note:''' We ensure that the byte array for each record in the
 resulting RDDs of the DStream has the provided record length.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>directory</CODE> - HDFS directory to monitor for new file<DD><CODE>recordLength</CODE> - length of each record in bytes
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="queueStream(scala.collection.mutable.Queue, boolean, scala.reflect.ClassTag)"><!-- --></A><H3>
queueStream</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;T&gt; <B>queueStream</B>(scala.collection.mutable.Queue&lt;<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;queue,
                                       boolean&nbsp;oneAtATime,
                                       scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$15)</PRE>
<DL>
<DD>Create an input stream from a queue of RDDs. In each batch,
 it will process either one or all of the RDDs returned by the queue.
 <p>
 NOTE: Arbitrary RDDs can be added to <code>queueStream</code>, there is no way to recover data of
 those RDDs, so <code>queueStream</code> doesn't support checkpointing.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>queue</CODE> - Queue of RDDs<DD><CODE>oneAtATime</CODE> - Whether only one RDD should be consumed from the queue in every interval<DD><CODE>evidence$15</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="queueStream(scala.collection.mutable.Queue, boolean, org.apache.spark.rdd.RDD, scala.reflect.ClassTag)"><!-- --></A><H3>
queueStream</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</A>&lt;T&gt; <B>queueStream</B>(scala.collection.mutable.Queue&lt;<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;queue,
                                       boolean&nbsp;oneAtATime,
                                       <A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&nbsp;defaultRDD,
                                       scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$16)</PRE>
<DL>
<DD>Create an input stream from a queue of RDDs. In each batch,
 it will process either one or all of the RDDs returned by the queue.
 <p>
 NOTE: Arbitrary RDDs can be added to <code>queueStream</code>, there is no way to recover data of
 those RDDs, so <code>queueStream</code> doesn't support checkpointing.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>queue</CODE> - Queue of RDDs<DD><CODE>oneAtATime</CODE> - Whether only one RDD should be consumed from the queue in every interval<DD><CODE>defaultRDD</CODE> - Default RDD is returned by the DStream when the queue is empty.
                   Set as null if no RDD should be returned when empty<DD><CODE>evidence$16</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="union(scala.collection.Seq, scala.reflect.ClassTag)"><!-- --></A><H3>
union</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;T&gt; <B>union</B>(scala.collection.Seq&lt;<A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;T&gt;&gt;&nbsp;streams,
                            scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$17)</PRE>
<DL>
<DD>Create a unified DStream from multiple DStreams of the same type and same slide duration.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>streams</CODE> - (undocumented)<DD><CODE>evidence$17</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="transform(scala.collection.Seq, scala.Function2, scala.reflect.ClassTag)"><!-- --></A><H3>
transform</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;T&gt; <B>transform</B>(scala.collection.Seq&lt;<A HREF="../../../../org/apache/spark/streaming/dstream/DStream.html" title="class in org.apache.spark.streaming.dstream">DStream</A>&lt;?&gt;&gt;&nbsp;dstreams,
                                scala.Function2&lt;scala.collection.Seq&lt;<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;?&gt;&gt;,<A HREF="../../../../org/apache/spark/streaming/Time.html" title="class in org.apache.spark.streaming">Time</A>,<A HREF="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</A>&lt;T&gt;&gt;&nbsp;transformFunc,
                                scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$18)</PRE>
<DL>
<DD>Create a new DStream in which each RDD is generated by applying a function on RDDs of
 the DStreams.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dstreams</CODE> - (undocumented)<DD><CODE>transformFunc</CODE> - (undocumented)<DD><CODE>evidence$18</CODE> - (undocumented)
<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="addStreamingListener(org.apache.spark.streaming.scheduler.StreamingListener)"><!-- --></A><H3>
addStreamingListener</H3>
<PRE>
public void <B>addStreamingListener</B>(<A HREF="../../../../org/apache/spark/streaming/scheduler/StreamingListener.html" title="interface in org.apache.spark.streaming.scheduler">StreamingListener</A>&nbsp;streamingListener)</PRE>
<DL>
<DD>Add a <A HREF="../../../../org/apache/spark/streaming/scheduler/StreamingListener.html" title="interface in org.apache.spark.streaming.scheduler"><CODE>StreamingListener</CODE></A> object for
 receiving system events related to streaming.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>streamingListener</CODE> - (undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="getState()"><!-- --></A><H3>
getState</H3>
<PRE>
public <A HREF="../../../../org/apache/spark/streaming/StreamingContextState.html" title="enum in org.apache.spark.streaming">StreamingContextState</A> <B>getState</B>()</PRE>
<DL>
<DD>:: DeveloperApi ::
 <p>
 Return the current state of the context. The context can be in three possible states -
 - StreamingContextState.INTIALIZED - The context has been created, but not been started yet.
   Input DStreams, transformations and output operations can be created on the context.
 - StreamingContextState.ACTIVE - The context has been started, and been not stopped.
   Input DStreams, transformations and output operations cannot be created on the context.
 - StreamingContextState.STOPPED - The context has been stopped and cannot be used any more.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>(undocumented)</DL>
</DD>
</DL>
<HR>

<A NAME="start()"><!-- --></A><H3>
start</H3>
<PRE>
public void <B>start</B>()</PRE>
<DL>
<DD>Start the execution of the streams.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>IllegalStateException</CODE> - if the StreamingContext is already stopped.</DL>
</DD>
</DL>
<HR>

<A NAME="awaitTermination()"><!-- --></A><H3>
awaitTermination</H3>
<PRE>
public void <B>awaitTermination</B>()</PRE>
<DL>
<DD>Wait for the execution to stop. Any exceptions that occurs during the execution
 will be thrown in this thread.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="awaitTermination(long)"><!-- --></A><H3>
awaitTermination</H3>
<PRE>
public void <B>awaitTermination</B>(long&nbsp;timeout)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of 1.3.0, replaced by <code>awaitTerminationOrTimeout(Long)</code>.</I>
<P>
<DD>Wait for the execution to stop. Any exceptions that occurs during the execution
 will be thrown in this thread.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - time to wait in milliseconds
 <p></DL>
</DD>
</DL>
<HR>

<A NAME="awaitTerminationOrTimeout(long)"><!-- --></A><H3>
awaitTerminationOrTimeout</H3>
<PRE>
public boolean <B>awaitTerminationOrTimeout</B>(long&nbsp;timeout)</PRE>
<DL>
<DD>Wait for the execution to stop. Any exceptions that occurs during the execution
 will be thrown in this thread.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - time to wait in milliseconds
<DT><B>Returns:</B><DD><code>true</code> if it's stopped; or throw the reported error during the execution; or <code>false</code>
         if the waiting time elapsed before returning from the method.</DL>
</DD>
</DL>
<HR>

<A NAME="stop(boolean)"><!-- --></A><H3>
stop</H3>
<PRE>
public void <B>stop</B>(boolean&nbsp;stopSparkContext)</PRE>
<DL>
<DD>Stop the execution of the streams immediately (does not wait for all received data
 to be processed). By default, if <code>stopSparkContext</code> is not specified, the underlying
 SparkContext will also be stopped. This implicit behavior can be configured using the
 SparkConf configuration spark.streaming.stopSparkContextByDefault.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stopSparkContext</CODE> - If true, stops the associated SparkContext. The underlying SparkContext
                         will be stopped regardless of whether this StreamingContext has been
                         started.</DL>
</DD>
</DL>
<HR>

<A NAME="stop(boolean, boolean)"><!-- --></A><H3>
stop</H3>
<PRE>
public void <B>stop</B>(boolean&nbsp;stopSparkContext,
                 boolean&nbsp;stopGracefully)</PRE>
<DL>
<DD>Stop the execution of the streams, with option of ensuring all received data
 has been processed.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stopSparkContext</CODE> - if true, stops the associated SparkContext. The underlying SparkContext
                         will be stopped regardless of whether this StreamingContext has been
                         started.<DD><CODE>stopGracefully</CODE> - if true, stops gracefully by waiting for the processing of all
                       received data to be completed</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/spark/streaming/Seconds.html" title="class in org.apache.spark.streaming"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/spark/streaming/StreamingContextState.html" title="enum in org.apache.spark.streaming"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/spark/streaming/StreamingContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="StreamingContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
